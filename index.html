<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PDF Speed Reader</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;600&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
        }

        /* --- CAROUSEL STYLES (Top Widget) --- */
        .carousel-viewport {
            overflow: hidden;
            width: 100%;
            border-radius: 0.75rem;
            background: white;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid #f3f4f6;
            position: relative;
            touch-action: pan-y; /* Allow vertical scroll, handle horizontal manually */
        }

        .carousel-track {
            display: flex;
            width: 200%; /* 2 Slides */
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }

        .carousel-slide {
            width: 50%; /* Each slide takes half of the 200% width (so 100% of viewport) */
            padding: 1rem;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .carousel-dots {
            position: absolute;
            bottom: 5px;
            left: 0; 
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 6px;
            pointer-events: none;
        }
        .dot {
            width: 6px; height: 6px;
            background: #d1d5db;
            border-radius: 50%;
            transition: background 0.3s;
        }
        .dot.active { background: #4f46e5; }

        /* --- READER DISPLAY --- */
        .reader-display {
            font-family: 'Roboto Mono', monospace;
            height: 240px; /* Slightly reduced height to fit buttons */
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            position: relative;
            user-select: none;
            overflow: hidden; 
        }

        .focus-guide-top, .focus-guide-bottom {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 10px;
            background-color: #e5e7eb;
        }
        .focus-guide-top { top: 20px; }
        .focus-guide-bottom { bottom: 20px; }

        .word-container {
            font-size: 50px; 
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            width: 100%;
            transition: font-size 0.1s ease-out; 
        }

        .focus-char { color: #ef4444; flex-shrink: 0; }
        .word-left { text-align: right; width: 50%; white-space: nowrap; }
        .word-right { text-align: left; width: 50%; white-space: nowrap; }
        .para-break { color: #9ca3af; font-size: 40px; }

        /* --- PREVIEW WIDGET --- */
        .page-preview-wrapper {
            width: 100%;
            height: 120px;
            background: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }
        .expand-hint {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center;
            color: white; opacity: 0;
            transition: opacity 0.2s; pointer-events: none;
        }
        .page-preview-wrapper:hover .expand-hint { opacity: 1; }

        /* --- MODAL --- */
        #page-modal {
            display: none;
            position: fixed; inset: 0; z-index: 60;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            align-items: center; justify-content: center;
            /* Disable default touch actions to handle gestures manually */
            touch-action: none; 
            overflow: hidden;
        }
        #page-modal.active { display: flex; }
        
        .modal-nav-btn {
            position: absolute; top: 50%; transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            color: white; border: 1px solid rgba(255,255,255,0.4);
            padding: 1rem; border-radius: 50%; cursor: pointer; z-index: 90;
            transition: background 0.2s;
        }
        .modal-nav-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .modal-prev { left: 20px; }
        .modal-next { right: 20px; }

        /* Close button z-index fix */
        #close-modal {
            z-index: 100;
        }
        
        #modal-canvas {
            transform-origin: center center;
            transition: transform 0.1s ease-out; /* Smooth pinch */
        }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95); z-index: 50;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
    </style>
</head>
<body class="text-gray-800">

    <!-- Loading Overlay -->
    <div id="loader">
        <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-indigo-600 mb-4"></div>
        <h2 class="text-lg font-semibold text-gray-700">Processing PDF...</h2>
        <p id="loading-status" class="text-sm text-gray-500 mt-2">Initializing...</p>
    </div>

    <!-- Full Screen Page Modal -->
    <div id="page-modal">
        <!-- Close Button: High Z-index, large touch target -->
        <button class="absolute top-6 right-6 text-white text-5xl font-light hover:text-gray-300 active:text-gray-400 drop-shadow-md leading-none w-12 h-12 flex items-center justify-center" id="close-modal">&times;</button>
        
        <!-- Page Number Indicator -->
        <div class="absolute bottom-6 left-1/2 -translate-x-1/2 bg-black/50 backdrop-blur-sm text-white px-4 py-1.5 rounded-full text-sm font-mono z-50 pointer-events-none" id="modal-page-num">
            Page -
        </div>

        <button class="modal-nav-btn modal-prev" id="modal-prev-btn"><i class="fa-solid fa-chevron-left"></i></button>
        
        <!-- Image Container -->
        <div class="relative w-full h-full p-2 flex items-center justify-center pointer-events-none">
            <!-- pointer-events-none on container ensures clicks pass through to modal bg for closing/swiping if needed, 
                 but we want swipes on the modal itself. -->
            <canvas id="modal-canvas" class="max-w-full max-h-full object-contain shadow-2xl bg-white pointer-events-auto"></canvas>
        </div>

        <button class="modal-nav-btn modal-next" id="modal-next-btn"><i class="fa-solid fa-chevron-right"></i></button>
    </div>

    <!-- Header -->
    <header class="bg-white shadow-sm p-3 flex justify-between items-center z-10 shrink-0 h-16">
        <div class="flex items-center gap-2">
            <i class="fa-solid fa-bolt text-yellow-500 text-xl"></i>
            <h1 class="text-lg font-bold tracking-tight text-gray-800">Speed<span class="text-indigo-600">Reader</span></h1>
        </div>
        <div>
            <label for="file-upload" class="cursor-pointer bg-indigo-600 active:bg-indigo-800 text-white px-3 py-2 rounded-lg text-sm shadow flex items-center gap-2">
                <i class="fa-solid fa-file-pdf"></i>
                <span>Open PDF</span>
            </label>
            <input id="file-upload" type="file" accept="application/pdf" class="hidden">
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-grow flex flex-col w-full max-w-lg mx-auto p-4 gap-4 overflow-y-auto">

        <!-- Top Widget: Swipeable Carousel -->
        <div class="carousel-viewport" id="top-widget-carousel">
            <div class="carousel-track" id="carousel-track">
                
                <!-- Slide 1: Controls -->
                <div class="carousel-slide">
                    <div class="flex flex-col h-full justify-between gap-2">
                        <!-- Jump To -->
                        <div>
                            <label class="text-xs font-bold text-gray-400 uppercase">Jump To</label>
                            <select id="chapter-select" class="w-full bg-gray-50 border border-gray-200 text-gray-700 text-sm rounded-lg p-2 mt-1">
                                <option value="" disabled selected>Load PDF</option>
                            </select>
                        </div>
                        
                        <!-- Speed Control -->
                        <div>
                            <div class="flex justify-between items-end mb-1">
                                <label class="text-xs font-bold text-gray-400 uppercase">Speed</label>
                                <span class="text-xs text-gray-500 font-mono"><span id="wpm-display">300</span> WPM</span>
                            </div>
                            <input type="range" id="wpm-slider" min="50" max="1000" step="10" value="300" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600">
                        </div>

                        <!-- Mini Stats -->
                        <div class="flex justify-between text-xs text-gray-400 pt-1 border-t border-gray-100">
                             <span>Words: <span id="total-words" class="text-gray-600 font-semibold">0</span></span>
                             <span class="text-indigo-500 font-semibold flex items-center gap-1">Swipe for Map <i class="fa-solid fa-arrow-right"></i></span>
                        </div>
                    </div>
                </div>

                <!-- Slide 2: Page Preview -->
                <div class="carousel-slide">
                    <div class="flex flex-col h-full items-center justify-center">
                        <div class="w-full flex justify-between items-center mb-1 px-1">
                            <label class="text-xs font-bold text-gray-400 uppercase">Current Page Location</label>
                            <span class="text-xs font-mono text-gray-500">Page <span id="current-page-num">-</span></span>
                        </div>
                        
                        <div class="page-preview-wrapper" id="preview-container">
                            <canvas id="preview-canvas" class="h-full object-contain"></canvas>
                            <div class="expand-hint"><i class="fa-solid fa-expand text-2xl drop-shadow-md"></i></div>
                        </div>
                    </div>
                </div>

            </div>
            
            <!-- Dots -->
            <div class="carousel-dots">
                <div class="dot active" id="dot-0"></div>
                <div class="dot" id="dot-1"></div>
            </div>
        </div>

        <!-- Reader Card (Bottom) - NOT Swipeable -->
        <div class="w-full reader-display shrink-0" id="reader-card">
            <div class="focus-guide-top"></div>
            <div id="word-display" class="word-container">
                <span class="word-left" id="word-left">Ready</span>
                <span class="focus-char" id="word-focus">?</span>
                <span class="word-right" id="word-right"></span>
            </div>
            <div id="para-indicator" class="hidden absolute top-4 right-4 text-gray-300 text-4xl">¶</div>
            <div class="focus-guide-bottom"></div>
        </div>

        <!-- Progress Bar -->
        <div class="w-full shrink-0">
            <div class="flex justify-between text-xs text-gray-500 font-mono px-1 mb-1">
                <span id="progress-text">0 / 0</span>
                <span id="time-remaining">0m left</span>
            </div>
            <input type="range" id="progress-slider" min="0" max="100" value="0" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-indigo-600">
        </div>

        <!-- Playback Controls -->
        <div class="flex gap-8 items-center justify-center pb-2 shrink-0">
            <button id="btn-restart" class="text-gray-400 hover:text-gray-600 active:scale-95 transition p-2" title="Restart">
                <i class="fa-solid fa-rotate-left text-2xl"></i>
            </button>

            <button id="btn-play-pause" class="bg-indigo-600 active:bg-indigo-800 text-white w-16 h-16 rounded-full shadow-lg flex items-center justify-center transition transform active:scale-95">
                <i class="fa-solid fa-play text-2xl pl-1" id="icon-play"></i>
                <i class="fa-solid fa-pause text-2xl hidden" id="icon-pause"></i>
            </button>

            <button id="btn-rewind" class="text-gray-400 hover:text-gray-600 active:scale-95 transition p-2" title="Back 10">
                <i class="fa-solid fa-backward text-2xl"></i>
            </button>
        </div>

    </main>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const state = {
            pdfDoc: null,
            words: [],
            wordIndex: 0,
            isPlaying: false,
            wpm: 300,
            timeoutId: null,
            pageMap: [],
            currentPage: 1,
            lastRenderedPage: 0,
            cachedPageImage: null,
            carouselIndex: 0 // 0 = Controls, 1 = Preview
        };

        const PARA_TOKEN = "___PARA___";

        const els = {
            fileInput: document.getElementById('file-upload'),
            loader: document.getElementById('loader'),
            loadStatus: document.getElementById('loading-status'),
            chapterSelect: document.getElementById('chapter-select'),
            wpmSlider: document.getElementById('wpm-slider'),
            wpmDisplay: document.getElementById('wpm-display'),
            
            // Carousel
            carouselWidget: document.getElementById('top-widget-carousel'),
            carouselTrack: document.getElementById('carousel-track'),
            dot0: document.getElementById('dot-0'),
            dot1: document.getElementById('dot-1'),

            // Reader
            wordDisplay: document.getElementById('word-display'),
            wordLeft: document.getElementById('word-left'),
            wordFocus: document.getElementById('word-focus'),
            wordRight: document.getElementById('word-right'),
            paraIndicator: document.getElementById('para-indicator'),
            
            // Progress
            progressText: document.getElementById('progress-text'),
            timeRemaining: document.getElementById('time-remaining'),
            progressSlider: document.getElementById('progress-slider'),
            totalWords: document.getElementById('total-words'),
            
            // Controls
            btnPlayPause: document.getElementById('btn-play-pause'),
            iconPlay: document.getElementById('icon-play'),
            iconPause: document.getElementById('icon-pause'),
            btnRestart: document.getElementById('btn-restart'),
            btnRewind: document.getElementById('btn-rewind'),
            
            // Preview
            previewCanvas: document.getElementById('preview-canvas'),
            previewContainer: document.getElementById('preview-container'),
            currentPageNum: document.getElementById('current-page-num'),
            
            // Modal
            modal: document.getElementById('page-modal'),
            modalCanvas: document.getElementById('modal-canvas'),
            closeModal: document.getElementById('close-modal'),
            modalPrev: document.getElementById('modal-prev-btn'),
            modalNext: document.getElementById('modal-next-btn'),
            modalPageNum: document.getElementById('modal-page-num')
        };

        // --- Event Listeners ---
        els.fileInput.addEventListener('change', handleFileUpload);
        els.btnPlayPause.addEventListener('click', togglePlay);
        els.btnRestart.addEventListener('click', () => jumpToWord(0));
        els.btnRewind.addEventListener('click', () => jumpToWord(state.wordIndex - 10));

        els.wpmSlider.addEventListener('input', (e) => {
            state.wpm = parseInt(e.target.value);
            els.wpmDisplay.textContent = state.wpm;
            updateTimeRemaining();
        });

        els.progressSlider.addEventListener('input', (e) => {
            if (state.words.length === 0) return;
            jumpToWord(parseInt(e.target.value));
        });

        els.chapterSelect.addEventListener('change', (e) => jumpToWord(parseInt(e.target.value)));

        document.addEventListener('keydown', (e) => {
            if (state.words.length === 0) return;
            if (els.modal.classList.contains('active')) {
                if (e.code === 'ArrowLeft') showModalPage(state.currentPage - 1);
                if (e.code === 'ArrowRight') showModalPage(state.currentPage + 1);
                if (e.code === 'Escape') closeModal();
                return;
            }
            if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
            else if (e.code === 'ArrowLeft') jumpToWord(state.wordIndex - 10);
            else if (e.code === 'ArrowRight') jumpToWord(state.wordIndex + 10);
        });

        // --- Carousel Logic (Swipe Top Widget) ---
        let cStartX = 0;
        let cEndX = 0;

        els.carouselWidget.addEventListener('touchstart', e => {
            cStartX = e.changedTouches[0].screenX;
        }, {passive: true});

        els.carouselWidget.addEventListener('touchend', e => {
            cEndX = e.changedTouches[0].screenX;
            handleCarouselSwipe();
        }, {passive: true});

        els.carouselWidget.addEventListener('mousedown', e => {
            cStartX = e.screenX;
        });
        
        els.carouselWidget.addEventListener('mouseup', e => {
            cEndX = e.screenX;
            handleCarouselSwipe();
        });

        function handleCarouselSwipe() {
            const diff = cEndX - cStartX;
            if (Math.abs(diff) > 50) {
                if (diff < 0) {
                    state.carouselIndex = 1; // Left swipe -> Map
                } else {
                    state.carouselIndex = 0; // Right swipe -> Controls
                }
                updateCarousel();
            }
        }

        function updateCarousel() {
            const offset = state.carouselIndex === 0 ? '0%' : '-50%';
            els.carouselTrack.style.transform = `translateX(${offset})`;
            
            if (state.carouselIndex === 0) {
                els.dot0.classList.add('active');
                els.dot1.classList.remove('active');
            } else {
                els.dot0.classList.remove('active');
                els.dot1.classList.add('active');
                const wordObj = state.words[state.wordIndex];
                if (wordObj) renderPageThumbnail(wordObj.page);
            }
        }

        // --- Modal Logic (Gesture Support) ---
        
        let mTouchStartX = 0;
        let mTouchStartY = 0;
        let mStartDist = 0;
        let mStartScale = 1;
        let mScale = 1;
        let mPanX = 0;
        let mPanY = 0;
        let mStartPanX = 0;
        let mStartPanY = 0;
        let mIsZooming = false;
        let mIsPanning = false;

        els.previewContainer.addEventListener('click', openModal);
        els.closeModal.addEventListener('click', closeModal);
        els.modalPrev.addEventListener('click', (e) => { e.stopPropagation(); showModalPage(state.currentPage - 1); });
        els.modalNext.addEventListener('click', (e) => { e.stopPropagation(); showModalPage(state.currentPage + 1); });
        
        // Modal Background Click
        els.modal.addEventListener('click', (e) => { 
            // Close if clicking outside the image (the background) but not panning
            if (e.target === els.modal && !mIsPanning && !mIsZooming) closeModal(); 
        });

        // Touch Handlers for Zoom/Pan/Swipe
        els.modal.addEventListener('touchstart', handleModalTouchStart, {passive: false});
        els.modal.addEventListener('touchmove', handleModalTouchMove, {passive: false});
        els.modal.addEventListener('touchend', handleModalTouchEnd);

        function handleModalTouchStart(e) {
            if (e.touches.length === 2) {
                // Pinch Start
                mIsZooming = true;
                mStartDist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                mStartScale = mScale;
            } else if (e.touches.length === 1) {
                if (mScale > 1.1) {
                    // Pan Start (only if zoomed in)
                    mIsPanning = true;
                    mStartPanX = e.touches[0].pageX - mPanX;
                    mStartPanY = e.touches[0].pageY - mPanY;
                } else {
                    // Swipe Nav Start
                    mTouchStartX = e.touches[0].screenX;
                }
            }
        }

        function handleModalTouchMove(e) {
            if (mIsZooming && e.touches.length === 2) {
                e.preventDefault();
                const dist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                const scaleChange = dist / mStartDist;
                mScale = Math.max(1, Math.min(4, mStartScale * scaleChange));
                updateModalTransform();
            } else if (mIsPanning && e.touches.length === 1) {
                e.preventDefault();
                mPanX = e.touches[0].pageX - mStartPanX;
                mPanY = e.touches[0].pageY - mStartPanY;
                updateModalTransform();
            }
        }

        function handleModalTouchEnd(e) {
            mIsZooming = false;
            mIsPanning = false;
            if (e.changedTouches.length === 1 && mScale <= 1.1) {
                // End Swipe Nav logic
                const mTouchEndX = e.changedTouches[0].screenX;
                const diff = mTouchEndX - mTouchStartX;
                if (Math.abs(diff) > 50) {
                    if (diff > 0) showModalPage(state.currentPage - 1);
                    else showModalPage(state.currentPage + 1);
                }
            }
        }

        function updateModalTransform() {
            els.modalCanvas.style.transform = `translate(${mPanX}px, ${mPanY}px) scale(${mScale})`;
        }

        function resetZoom() {
            mScale = 1;
            mPanX = 0;
            mPanY = 0;
            updateModalTransform();
        }

        function openModal() {
            if (!state.pdfDoc) return;
            els.modal.classList.add('active');
            stopReader();
            showModalPage(state.currentPage);
        }

        function closeModal() { 
            els.modal.classList.remove('active'); 
            
            if (!state.words || state.words.length === 0) return;

            // Sync Main Reader with Modal Page if changed
            const currentWordObj = state.words[state.wordIndex];
            const currentWordPage = currentWordObj ? currentWordObj.page : 1;
            
            if (state.currentPage !== currentWordPage) {
                const newIndex = state.pageMap[state.currentPage] || 0;
                renderPageThumbnail(state.currentPage);
                jumpToWord(newIndex);
            }
        }

        async function showModalPage(pageNum) {
            if (pageNum < 1 || pageNum > state.pdfDoc.numPages) return;
            
            // Reset zoom when changing page
            resetZoom();

            state.currentPage = pageNum;
            
            // Update UI Counters (In Modal and Main UI)
            els.modalPageNum.textContent = `Page ${pageNum} / ${state.pdfDoc.numPages}`;
            els.currentPageNum.textContent = pageNum;

            const page = await state.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 2.0 });

            els.modalCanvas.height = viewport.height;
            els.modalCanvas.width = viewport.width;

            const ctx = els.modalCanvas.getContext('2d');
            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
        }

        // --- Parsing & Processing ---

        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (file.type !== 'application/pdf') { alert('Invalid PDF'); return; }

            els.loader.style.display = 'flex';
            try {
                const buffer = await file.arrayBuffer();
                state.pdfDoc = await pdfjsLib.getDocument({ data: buffer }).promise;
                await extractContent(state.pdfDoc);
                
                els.progressSlider.max = state.words.length - 1;
                els.totalWords.textContent = state.words.length.toLocaleString();
                jumpToWord(0);
                els.loader.style.display = 'none';
            } catch (err) {
                console.error(err);
                alert('Parsing failed. Password protected?');
                els.loader.style.display = 'none';
            }
        }

        async function extractContent(pdf) {
            state.words = [];
            state.pageMap = [];
            els.chapterSelect.innerHTML = '';

            let currentWordCount = 0;

            for (let i = 1; i <= pdf.numPages; i++) {
                if (i%5===0) els.loadStatus.textContent = `Page ${i}/${pdf.numPages}...`;
                state.pageMap[i] = currentWordCount;

                const page = await pdf.getPage(i);
                const viewport = page.getViewport({ scale: 1.0 }); // Needed for context height
                const content = await page.getTextContent();
                let pageWords = [];
                let lastY = -1;
                let lastStr = "";

                content.items.forEach(item => {
                    const str = item.str;
                    if (!str.trim()) return;
                    
                    const tx = item.transform;
                    const x = tx[4]; const y = tx[5];
                    const w = item.width; const h = item.height || 12;

                    // --- Page Number / Header / Footer Detection ---
                    const isBottom = y < 60; // Approx 1 inch from bottom (72 DPI)
                    const isTop = y > (viewport.height - 60); 
                    // Matches "12", "- 12 -", "Page 12", "12/40", "iv"
                    // Allow simple digit, "page" + digits, roman numerals, or "X / Y"
                    const pageNumRegex = /^-?\s*(page\s*)?(\d+|[ivxlc]+)(\s*\/\s*\d+)?\s*-?$/i;
                    
                    if ((isBottom || isTop) && pageNumRegex.test(str.trim())) {
                        return; // Skip likely page numbers
                    }

                    // --- Paragraph Break Detection ---
                    if (lastY !== -1) {
                         const dist = Math.abs(y - lastY);
                         // Dynamic threshold + ensure prev word wasn't hyphenated
                         if (dist > (h * 2.5) && !lastStr.trim().endsWith('-')) {
                             pageWords.push({ text: PARA_TOKEN, page: i, x, y, w: 0, h: 0 });
                         }
                    }

                    const words = str.split(/\s+/).filter(s => s.length > 0);
                    if (words.length > 0) {
                        const charW = w / str.length;
                        let cx = x;
                        words.forEach(txt => {
                            const ww = txt.length * charW;
                            pageWords.push({ text: txt, page: i, x: cx, y, w: ww, h });
                            cx += ww + charW;
                        });
                    }
                    lastY = y;
                    lastStr = str;
                });

                // --- Punctuation Merge ---
                const cleanWords = [];
                for (let k = 0; k < pageWords.length; k++) {
                    const cur = pageWords[k];
                    if (cur.text === PARA_TOKEN) { cleanWords.push(cur); continue; }

                    // Forward Merge (Open Quotes)
                    // Matches “ ‘ ( [ { « and straight quotes if followed by alphanumeric
                    const isOpenQuote = /^[“‘(\[{«]$/.test(cur.text) || 
                                        ((cur.text === '"' || cur.text === "'") && k+1 < pageWords.length && /^[a-zA-Z0-9]/.test(pageWords[k+1].text));
                    
                    if (isOpenQuote && k + 1 < pageWords.length && pageWords[k+1].text !== PARA_TOKEN) {
                         const next = pageWords[k+1];
                         next.text = cur.text + next.text;
                         next.x = cur.x; // Use quote start
                         next.w += cur.w;
                         continue; 
                    }

                    // Backward Merge (Trailing Punctuation)
                    // Matches . , ; : ? ! … » ” ’ ) ] } and straight quotes (if not open)
                    const isTrailing = /^[.,;:?!…»”’')\]}]+$/.test(cur.text) || cur.text === '"' || cur.text === "'";
                    
                    if (isTrailing && cleanWords.length > 0) {
                         const prev = cleanWords[cleanWords.length - 1];
                         if (prev.text !== PARA_TOKEN) {
                             prev.text += cur.text;
                             prev.w += cur.w;
                             continue;
                         }
                    }
                    cleanWords.push(cur);
                }
                
                // Replace pageWords with clean version for hyphen step
                pageWords = cleanWords;

                // --- Merge Hyphens ---
                const finalPageWords = [];
                for (let j = 0; j < pageWords.length; j++) {
                    let cur = pageWords[j];
                    if (cur.text === PARA_TOKEN) { finalPageWords.push(cur); continue; }

                    if (cur.text.endsWith('-') && j+1 < pageWords.length) {
                        let next = pageWords[j+1];
                        if (next.text !== PARA_TOKEN && /^[a-z]/.test(next.text)) {
                            cur.text = cur.text.slice(0, -1) + next.text;
                            cur.w += next.w;
                            j++;
                        }
                    }
                    finalPageWords.push(cur);
                }
                
                state.words.push(...finalPageWords);
                currentWordCount += finalPageWords.length;
            }

            // Outline
            els.loadStatus.textContent = 'Building Outline...';
            const outline = await pdf.getOutline();
            if (outline) {
                for (const o of outline) {
                    try {
                        let dest = o.dest;
                        let pIdx = -1;
                        if (typeof dest === 'string') pIdx = await pdf.getPageIndex(dest);
                        else if (Array.isArray(dest)) pIdx = await pdf.getPageIndex(dest[0]);
                        
                        if (pIdx !== -1) {
                            addOption(o.title, state.pageMap[pIdx + 1] || 0);
                        }
                    } catch(e){}
                }
            }
            if (els.chapterSelect.options.length === 0) {
                for (let i = 1; i <= pdf.numPages; i++) {
                    addOption(`Page ${i}`, state.pageMap[i]);
                }
            }
        }

        function addOption(txt, val) {
            const o = document.createElement('option');
            o.text = txt; o.value = val;
            els.chapterSelect.add(o);
        }

        // --- Reader Engine ---

        function jumpToWord(idx) {
            state.wordIndex = Math.max(0, Math.min(idx, state.words.length - 1));
            updateDisplay();
            updateProgress();
            
            const wObj = state.words[state.wordIndex];
            if (wObj && wObj.page !== state.currentPage) {
                if (state.carouselIndex === 1) renderPageThumbnail(wObj.page);
                else {
                    state.currentPage = wObj.page;
                    state.lastRenderedPage = 0; 
                }
            } else if (state.carouselIndex === 1) {
                drawHighlight();
            }
        }

        function togglePlay() {
            if (state.words.length === 0) return;
            state.isPlaying ? stopReader() : startReader();
        }

        function startReader() {
            if (state.wordIndex >= state.words.length) state.wordIndex = 0;
            state.isPlaying = true;
            els.iconPlay.classList.add('hidden');
            els.iconPause.classList.remove('hidden');
            readerLoop();
        }

        function stopReader() {
            state.isPlaying = false;
            clearTimeout(state.timeoutId);
            els.iconPlay.classList.remove('hidden');
            els.iconPause.classList.add('hidden');
        }

        function readerLoop() {
            if (!state.isPlaying || state.wordIndex >= state.words.length) {
                stopReader(); return;
            }

            const wObj = state.words[state.wordIndex];
            const baseDelay = 60000 / state.wpm;
            let factor = 1.0;

            if (wObj.text === PARA_TOKEN) {
                showParaBreak();
                state.wordIndex++;
                updateProgress();
                state.timeoutId = setTimeout(() => {
                    hideParaBreak();
                    readerLoop();
                }, baseDelay * 3);
                return;
            }

            renderRSVPWord(wObj.text);
            updateProgress();

            if (state.carouselIndex === 1) {
                if (wObj.page !== state.currentPage) renderPageThumbnail(wObj.page);
                else drawHighlight();
            } else if (wObj.page !== state.currentPage) {
                state.currentPage = wObj.page;
                state.lastRenderedPage = 0; 
            }

            // Word Length Factors
            const len = wObj.text.length;
            if (len > 7) factor = 2.5;
            else if (len < 4) factor = 0.8;
            
            // Punctuation Factors
            // Check for Period (and optionally closing quotes)
            if (/\.['"”’)]*$/.test(wObj.text)) {
                factor += 2.0; // Add pause equivalent to 2 words
            } 
            // Check for ! or ? (Sentence endings)
            else if (/[?!]['"”’)]*$/.test(wObj.text)) {
                factor += 2.0; 
            } 
            // Check for semi-colons or colons
            else if (/[;:].*$/.test(wObj.text)) {
                factor *= 1.5;
            } 
            // Check for commas
            else if (/,.*$/.test(wObj.text)) {
                factor *= 1.2;
            }

            state.wordIndex++;
            state.timeoutId = setTimeout(readerLoop, baseDelay * factor);
        }

        function showParaBreak() {
            els.wordLeft.textContent = "";
            els.wordFocus.textContent = "";
            els.wordRight.textContent = "";
            els.paraIndicator.classList.remove('hidden');
        }

        function hideParaBreak() {
            els.paraIndicator.classList.add('hidden');
        }

        function renderRSVPWord(word) {
            const len = word.length;
            if (len > 12) els.wordDisplay.style.fontSize = "40px";
            else if (len > 8) els.wordDisplay.style.fontSize = "45px";
            else els.wordDisplay.style.fontSize = "55px";

            const focusIdx = Math.floor((len - 1) / 2);
            els.wordLeft.textContent = word.substring(0, focusIdx);
            els.wordFocus.textContent = word.charAt(focusIdx);
            els.wordRight.textContent = word.substring(focusIdx + 1);
        }

        function updateProgress() {
            els.progressSlider.value = state.wordIndex;
            els.progressText.textContent = `${state.wordIndex + 1}/${state.words.length}`;
            if (state.wordIndex % 5 === 0) updateTimeRemaining();
        }

        function updateTimeRemaining() {
            const left = state.words.length - state.wordIndex;
            const mins = Math.ceil(left / state.wpm);
            els.timeRemaining.textContent = left > 0 ? `${mins}m left` : "Done";
        }

        // --- Thumbnail Logic ---
        
        async function renderPageThumbnail(pageNum) {
            if (!state.pdfDoc) return;
            if (pageNum === state.lastRenderedPage && state.cachedPageImage) {
                drawHighlight(); return;
            }

            state.currentPage = pageNum;
            state.lastRenderedPage = pageNum;
            els.currentPageNum.textContent = pageNum;

            const page = await state.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 0.5 });

            els.previewCanvas.height = viewport.height;
            els.previewCanvas.width = viewport.width;

            const ctx = els.previewCanvas.getContext('2d');
            state.currentThumbnailViewport = viewport;

            await page.render({ canvasContext: ctx, viewport }).promise;
            
            createImageBitmap(els.previewCanvas).then(img => {
                state.cachedPageImage = img;
                drawHighlight();
            });
        }

        function drawHighlight() {
            if (!state.cachedPageImage || !state.currentThumbnailViewport) return;
            const ctx = els.previewCanvas.getContext('2d');
            
            ctx.clearRect(0,0, els.previewCanvas.width, els.previewCanvas.height);
            ctx.drawImage(state.cachedPageImage, 0, 0);

            const wObj = state.words[state.wordIndex];
            if (!wObj || wObj.text === PARA_TOKEN || wObj.page !== state.currentPage) return;

            const rect = state.currentThumbnailViewport.convertToViewportRectangle([
                wObj.x, wObj.y, wObj.x + wObj.w, wObj.y + wObj.h
            ]);
            
            const rx = Math.min(rect[0], rect[2]);
            const ry = Math.min(rect[1], rect[3]);
            const rw = Math.abs(rect[2] - rect[0]);
            const rh = Math.abs(rect[3] - rect[1]);

            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.fillRect(rx, ry, rw, rh);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(rx, ry, rw, rh);
        }
    </script>
</body>
</html>



