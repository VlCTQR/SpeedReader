<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PDF Speed Reader</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;600&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
        }

        /* --- CAROUSEL STYLES (Top Widget) --- */
        .carousel-viewport {
            overflow: hidden;
            width: 100%;
            border-radius: 0.75rem;
            background: white;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid #f3f4f6;
            position: relative;
            touch-action: pan-y; 
        }

        .carousel-track {
            display: flex;
            width: 200%; 
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }

        .carousel-slide {
            width: 50%; 
            padding: 1rem;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .carousel-dots {
            position: absolute;
            bottom: 5px;
            left: 0; 
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 6px;
            pointer-events: none;
        }
        .dot {
            width: 6px; height: 6px;
            background: #d1d5db;
            border-radius: 50%;
            transition: background 0.3s;
        }
        .dot.active { background: #4f46e5; }

        /* --- READER DISPLAY --- */
        .reader-display {
            font-family: 'Roboto Mono', monospace;
            height: 240px; 
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            position: relative;
            user-select: none;
            overflow: hidden; 
            padding-right: 1rem; 
        }

        .focus-guide-top, .focus-guide-bottom {
            position: absolute;
            left: 30%; 
            transform: translateX(-50%);
            width: 2px;
            height: 10px;
            background-color: #e5e7eb;
        }
        .focus-guide-top { top: 20px; }
        .focus-guide-bottom { bottom: 20px; }

        .word-container {
            font-size: 34px; 
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            width: 100%;
            transition: font-size 0.1s ease-out; 
        }

        .focus-char { color: #ef4444; flex-shrink: 0; }
        
        .word-left { 
            text-align: right; 
            width: 30%; 
            white-space: nowrap; 
        }
        .word-right { 
            text-align: left; 
            width: 70%; 
            white-space: nowrap; 
        }
        .para-break { color: #9ca3af; font-size: 27px; } 

        /* --- PREVIEW WIDGET --- */
        .page-preview-wrapper {
            width: 100%;
            /* Fixed height for mobile, overridden by flex-grow on desktop via JS/Classes */
            background: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
        }
        .expand-hint {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center;
            color: white; opacity: 0;
            transition: opacity 0.2s; pointer-events: none;
        }
        .page-preview-wrapper:hover .expand-hint { opacity: 1; }

        /* --- MODAL --- */
        #page-modal {
            display: none;
            position: fixed; inset: 0; z-index: 60;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            align-items: center; justify-content: center;
            touch-action: none; 
            overflow: hidden;
        }
        #page-modal.active { display: flex; }
        
        .modal-nav-btn {
            position: absolute; top: 50%; transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            color: white; border: 1px solid rgba(255,255,255,0.4);
            padding: 1rem; border-radius: 50%; cursor: pointer; z-index: 90;
            transition: background 0.2s;
        }
        .modal-nav-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .modal-prev { left: 20px; }
        .modal-next { right: 20px; }

        #close-modal { z-index: 100; }
        
        #modal-canvas {
            transform-origin: center center;
            transition: transform 0.1s ease-out; 
        }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95); z-index: 50;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
    </style>
</head>
<body class="text-gray-800">

    <!-- Loading Overlay -->
    <div id="loader">
        <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-indigo-600 mb-4"></div>
        <h2 class="text-lg font-semibold text-gray-700">Processing PDF...</h2>
        <p id="loading-status" class="text-sm text-gray-500 mt-2">Initializing...</p>
    </div>

    <!-- Full Screen Page Modal -->
    <div id="page-modal">
        <button class="absolute top-6 right-6 text-white text-5xl font-light hover:text-gray-300 active:text-gray-400 drop-shadow-md leading-none w-12 h-12 flex items-center justify-center" id="close-modal">&times;</button>
        <div class="absolute bottom-6 left-1/2 -translate-x-1/2 bg-black/50 backdrop-blur-sm text-white px-4 py-1.5 rounded-full text-sm font-mono z-50 pointer-events-none" id="modal-page-num">Page -</div>
        <button class="modal-nav-btn modal-prev" id="modal-prev-btn"><i class="fa-solid fa-chevron-left"></i></button>
        <div class="relative w-full h-full p-2 flex items-center justify-center pointer-events-none">
            <canvas id="modal-canvas" class="max-w-full max-h-full object-contain shadow-2xl bg-white pointer-events-auto"></canvas>
        </div>
        <button class="modal-nav-btn modal-next" id="modal-next-btn"><i class="fa-solid fa-chevron-right"></i></button>
    </div>

    <!-- Header -->
    <header class="bg-white shadow-sm p-3 flex justify-between items-center z-10 shrink-0 h-16">
        <div class="flex items-center gap-2">
            <i class="fa-solid fa-bolt text-yellow-500 text-xl"></i>
            <h1 class="text-lg font-bold tracking-tight text-gray-800">Speed<span class="text-indigo-600">Reader</span></h1>
        </div>
        <div>
            <label for="file-upload" class="cursor-pointer bg-indigo-600 active:bg-indigo-800 text-white px-3 py-2 rounded-lg text-sm shadow flex items-center gap-2">
                <i class="fa-solid fa-file-pdf"></i>
                <span>Open PDF</span>
            </label>
            <input id="file-upload" type="file" accept="application/pdf" class="hidden">
        </div>
    </header>

    <!-- Main Content Area -->
    <main id="main-container" class="flex-grow flex flex-col w-full max-w-7xl mx-auto p-4 gap-4 overflow-y-auto lg:overflow-hidden">
        
        <!-- Mobile Carousel Structure (Default) -->
        <div id="mobile-carousel-wrapper" class="carousel-viewport lg:hidden shrink-0">
            <div class="carousel-track" id="carousel-track">
                <!-- Slide 1 Container -->
                <div class="carousel-slide" id="slide-1">
                    <!-- Controls Group moved here via JS or default -->
                </div>
                <!-- Slide 2 Container -->
                <div class="carousel-slide" id="slide-2">
                    <!-- Preview Group moved here via JS or default -->
                </div>
            </div>
            <div class="carousel-dots">
                <div class="dot active" id="dot-0"></div>
                <div class="dot" id="dot-1"></div>
            </div>
        </div>

        <!-- Desktop Grid Container (Initially hidden via class logic in JS or empty) -->
        <div id="desktop-grid" class="hidden lg:grid grid-cols-2 gap-6 h-full min-h-0">
            <!-- Left Column: Removed justify-center and padding to align to top -->
            <div id="desktop-left" class="flex flex-col gap-4 h-full min-h-0 overflow-y-auto">
                <!-- Content will be injected here -->
            </div>
            <div id="desktop-right" class="flex flex-col items-center justify-center bg-gray-200 rounded-xl p-6 shadow-inner h-full min-h-0">
                <!-- Map will be injected here -->
            </div>
        </div>

        <!-- CONTENT GROUPS (These are moved around the DOM based on layout) -->
        
        <!-- 1. Controls Group -->
        <div id="controls-group" class="flex flex-col w-full shrink-0">
            <!-- Inner wrapper acts as card on desktop, transparent on mobile (managed by JS classes or structure) -->
            <div id="controls-card-inner" class="flex flex-col gap-2 w-full h-full justify-between">
                <div>
                    <label class="text-xs font-bold text-gray-400 uppercase">Jump To</label>
                    <select id="chapter-select" class="w-full bg-gray-50 border border-gray-200 text-gray-700 text-sm rounded-lg p-2 mt-1">
                        <option value="" disabled selected>Load PDF</option>
                    </select>
                </div>
                <div>
                    <div class="flex justify-between items-end mb-1">
                        <label class="text-xs font-bold text-gray-400 uppercase">Speed</label>
                        <span class="text-xs text-gray-500 font-mono"><span id="wpm-display">300</span> WPM</span>
                    </div>
                    <input type="range" id="wpm-slider" min="50" max="1000" step="10" value="300" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600">
                </div>
                <div class="flex justify-between text-xs text-gray-400 pt-1 border-t border-gray-100 lg:hidden">
                     <span>Words: <span id="total-words-mobile" class="text-gray-600 font-semibold">0</span></span>
                     <span class="text-indigo-500 font-semibold flex items-center gap-1">Swipe for Map <i class="fa-solid fa-arrow-right"></i></span>
                </div>
                <!-- Desktop only stats -->
                <div class="hidden lg:block text-xs text-gray-400 pt-1">
                    Total Words: <span id="total-words-desktop" class="text-gray-600 font-bold">0</span>
                </div>
            </div>
        </div>

        <!-- 2. Preview Group -->
        <div id="preview-group" class="flex flex-col h-full items-center justify-center w-full">
            <div class="w-full flex justify-between items-center mb-1 px-1 lg:mb-2">
                <label class="text-xs font-bold text-gray-400 uppercase">Current Page Location</label>
                <span class="text-xs font-mono text-gray-500">Page <span id="current-page-num">-</span></span>
            </div>
            
            <!-- Wrapper height is dynamic: fixed on mobile, flex on desktop -->
            <div class="page-preview-wrapper h-[120px] lg:h-full lg:w-full lg:flex-grow" id="preview-container">
                <canvas id="preview-canvas" class="h-full w-full object-contain"></canvas>
                <div class="expand-hint"><i class="fa-solid fa-expand text-2xl drop-shadow-md"></i></div>
            </div>
        </div>

        <!-- 3. Reader Card -->
        <div id="reader-group" class="w-full shrink-0">
            <div class="w-full reader-display" id="reader-card">
                <div class="focus-guide-top"></div>
                <div id="word-display" class="word-container">
                    <span class="word-left" id="word-left">Load</span>
                    <span class="focus-char" id="word-focus">P</span>
                    <span class="word-right" id="word-right">DF</span>
                </div>
                <div id="para-indicator" class="hidden absolute top-4 right-4 text-gray-300 text-4xl">¶</div>
                <div class="focus-guide-bottom"></div>
            </div>
        </div>

        <!-- 4. Progress Bar -->
        <div id="progress-group" class="w-full shrink-0">
            <div class="flex justify-between text-xs text-gray-500 font-mono px-1 mb-1">
                <span id="progress-text">0 / 0</span>
                <span id="time-remaining">0m left</span>
            </div>
            <input type="range" id="progress-slider" min="0" max="100" value="0" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-indigo-600">
        </div>

        <!-- 5. Playback Controls -->
        <div id="playback-group" class="flex gap-8 items-center justify-center pb-2 shrink-0">
            <button id="btn-restart" class="text-gray-400 hover:text-gray-600 active:scale-95 transition p-2" title="Restart">
                <i class="fa-solid fa-rotate-left text-2xl"></i>
            </button>

            <button id="btn-play-pause" class="bg-indigo-600 active:bg-indigo-800 text-white w-16 h-16 rounded-full shadow-lg flex items-center justify-center transition transform active:scale-95">
                <i class="fa-solid fa-play text-2xl pl-1" id="icon-play"></i>
                <i class="fa-solid fa-pause text-2xl hidden" id="icon-pause"></i>
            </button>

            <button id="btn-rewind" class="text-gray-400 hover:text-gray-600 active:scale-95 transition p-2" title="Back 10">
                <i class="fa-solid fa-backward text-2xl"></i>
            </button>
        </div>

    </main>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const state = {
            pdfDoc: null,
            words: [],
            wordIndex: 0,
            isPlaying: false,
            wpm: 300,
            timeoutId: null,
            pageMap: [],
            currentPage: 0, // Changed from 1 to 0 to force initial render
            lastRenderedPage: 0,
            cachedPageImage: null,
            carouselIndex: 0,
            isDesktop: false
        };

        const PARA_TOKEN = "___PARA___";

        const els = {
            // Layout Containers
            slide1: document.getElementById('slide-1'),
            slide2: document.getElementById('slide-2'),
            mainContainer: document.getElementById('main-container'),
            desktopLeft: document.getElementById('desktop-left'),
            desktopRight: document.getElementById('desktop-right'),
            mobileCarousel: document.getElementById('mobile-carousel-wrapper'),
            desktopGrid: document.getElementById('desktop-grid'),

            // Groups
            controlsGroup: document.getElementById('controls-group'),
            controlsCardInner: document.getElementById('controls-card-inner'),
            previewGroup: document.getElementById('preview-group'),
            readerGroup: document.getElementById('reader-group'),
            progressGroup: document.getElementById('progress-group'),
            playbackGroup: document.getElementById('playback-group'),

            // UI Elements
            fileInput: document.getElementById('file-upload'),
            loader: document.getElementById('loader'),
            loadStatus: document.getElementById('loading-status'),
            chapterSelect: document.getElementById('chapter-select'),
            wpmSlider: document.getElementById('wpm-slider'),
            wpmDisplay: document.getElementById('wpm-display'),
            
            // Carousel
            carouselTrack: document.getElementById('carousel-track'),
            dot0: document.getElementById('dot-0'),
            dot1: document.getElementById('dot-1'),

            // Reader
            wordDisplay: document.getElementById('word-display'),
            wordLeft: document.getElementById('word-left'),
            wordFocus: document.getElementById('word-focus'),
            wordRight: document.getElementById('word-right'),
            paraIndicator: document.getElementById('para-indicator'),
            
            // Progress
            progressText: document.getElementById('progress-text'),
            timeRemaining: document.getElementById('time-remaining'),
            progressSlider: document.getElementById('progress-slider'),
            totalWordsMobile: document.getElementById('total-words-mobile'),
            totalWordsDesktop: document.getElementById('total-words-desktop'),
            
            // Controls
            btnPlayPause: document.getElementById('btn-play-pause'),
            iconPlay: document.getElementById('icon-play'),
            iconPause: document.getElementById('icon-pause'),
            btnRestart: document.getElementById('btn-restart'),
            btnRewind: document.getElementById('btn-rewind'),
            
            // Preview
            previewCanvas: document.getElementById('preview-canvas'),
            previewContainer: document.getElementById('preview-container'),
            currentPageNum: document.getElementById('current-page-num'),
            
            // Modal
            modal: document.getElementById('page-modal'),
            modalCanvas: document.getElementById('modal-canvas'),
            closeModal: document.getElementById('close-modal'),
            modalPrev: document.getElementById('modal-prev-btn'),
            modalNext: document.getElementById('modal-next-btn'),
            modalPageNum: document.getElementById('modal-page-num')
        };

        // --- Layout Management ---
        
        function handleResize() {
            const isDesktopNow = window.innerWidth >= 1024;
            
            // Only update DOM if state changes to prevent unnecessary re-renders
            if (isDesktopNow !== state.isDesktop || !state.layoutInitialized) {
                state.isDesktop = isDesktopNow;
                state.layoutInitialized = true;
                
                if (state.isDesktop) {
                    // Switch to Desktop
                    els.desktopGrid.classList.remove('hidden');
                    els.mobileCarousel.classList.add('hidden');
                    
                    // Add Card Styling to Controls for Desktop
                    els.controlsCardInner.classList.add('bg-white', 'p-4', 'rounded-xl', 'shadow-sm', 'border', 'border-gray-100');
                    els.controlsGroup.classList.remove('h-full'); // Remove full height stretch on desktop

                    // Move Elements to Desktop Grid
                    els.desktopLeft.appendChild(els.controlsGroup);
                    els.desktopLeft.appendChild(els.readerGroup);
                    els.desktopLeft.appendChild(els.progressGroup);
                    els.desktopLeft.appendChild(els.playbackGroup);
                    
                    els.desktopRight.appendChild(els.previewGroup);
                    
                    // Force re-render of map for quality
                    state.lastRenderedPage = 0; 
                    if (state.words.length > 0) {
                        const curWord = state.words[state.wordIndex];
                        renderPageThumbnail(curWord ? curWord.page : (state.currentPage || 1));
                    }

                } else {
                    // Switch to Mobile
                    els.desktopGrid.classList.add('hidden');
                    els.mobileCarousel.classList.remove('hidden');
                    
                    // Remove Card Styling from Controls for Mobile (Carousel handles container)
                    els.controlsCardInner.classList.remove('bg-white', 'p-4', 'rounded-xl', 'shadow-sm', 'border', 'border-gray-100');
                    els.controlsGroup.classList.add('h-full'); // Restore full height for carousel slide

                    // Restore Carousel
                    els.slide1.appendChild(els.controlsGroup);
                    els.slide2.appendChild(els.previewGroup);
                    
                    // Restore Main Flow
                    els.mainContainer.appendChild(els.readerGroup);
                    els.mainContainer.appendChild(els.progressGroup);
                    els.mainContainer.appendChild(els.playbackGroup);
                    
                    // Force re-render map (smaller)
                    state.lastRenderedPage = 0;
                    if (state.words.length > 0) {
                        const curWord = state.words[state.wordIndex];
                        renderPageThumbnail(curWord ? curWord.page : (state.currentPage || 1));
                    }
                }
            }
        }

        window.addEventListener('resize', () => {
            // Simple debounce
            clearTimeout(state.resizeTimer);
            state.resizeTimer = setTimeout(handleResize, 100);
        });
        
        // Initial Layout Check
        handleResize();


        // --- Event Listeners ---
        els.fileInput.addEventListener('change', handleFileUpload);
        els.btnPlayPause.addEventListener('click', togglePlay);
        els.btnRestart.addEventListener('click', () => jumpToWord(0));
        els.btnRewind.addEventListener('click', () => jumpToWord(state.wordIndex - 10));

        els.wpmSlider.addEventListener('input', (e) => {
            state.wpm = parseInt(e.target.value);
            els.wpmDisplay.textContent = state.wpm;
            updateTimeRemaining();
        });

        els.progressSlider.addEventListener('input', (e) => {
            if (state.words.length === 0) return;
            jumpToWord(parseInt(e.target.value));
        });

        els.chapterSelect.addEventListener('change', (e) => jumpToWord(parseInt(e.target.value)));

        document.addEventListener('keydown', (e) => {
            if (state.words.length === 0) return;
            if (els.modal.classList.contains('active')) {
                if (e.code === 'ArrowLeft') showModalPage(state.currentPage - 1);
                if (e.code === 'ArrowRight') showModalPage(state.currentPage + 1);
                if (e.code === 'Escape') closeModal();
                return;
            }
            if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
            else if (e.code === 'ArrowLeft') jumpToWord(state.wordIndex - 10);
            else if (e.code === 'ArrowRight') jumpToWord(state.wordIndex + 10);
        });

        // --- Carousel Logic (Swipe Top Widget) ---
        let cStartX = 0;
        let cEndX = 0;

        els.mobileCarousel.addEventListener('touchstart', e => {
            cStartX = e.changedTouches[0].screenX;
        }, {passive: true});

        els.mobileCarousel.addEventListener('touchend', e => {
            cEndX = e.changedTouches[0].screenX;
            handleCarouselSwipe();
        }, {passive: true});

        els.mobileCarousel.addEventListener('mousedown', e => {
            cStartX = e.screenX;
        });
        
        els.mobileCarousel.addEventListener('mouseup', e => {
            cEndX = e.screenX;
            handleCarouselSwipe();
        });

        function handleCarouselSwipe() {
            if (state.isDesktop) return; // Disable swipe logic on desktop
            const diff = cEndX - cStartX;
            if (Math.abs(diff) > 50) {
                if (diff < 0) {
                    state.carouselIndex = 1; // Left swipe -> Map
                } else {
                    state.carouselIndex = 0; // Right swipe -> Controls
                }
                updateCarousel();
            }
        }

        function updateCarousel() {
            const offset = state.carouselIndex === 0 ? '0%' : '-50%';
            els.carouselTrack.style.transform = `translateX(${offset})`;
            
            if (state.carouselIndex === 0) {
                els.dot0.classList.add('active');
                els.dot1.classList.remove('active');
            } else {
                els.dot0.classList.remove('active');
                els.dot1.classList.add('active');
                const wordObj = state.words[state.wordIndex];
                if (wordObj) renderPageThumbnail(wordObj.page);
            }
        }

        // --- Modal Logic (Gesture Support) ---
        
        let mTouchStartX = 0;
        let mTouchStartY = 0;
        let mStartDist = 0;
        let mStartScale = 1;
        let mScale = 1;
        let mPanX = 0;
        let mPanY = 0;
        let mStartPanX = 0;
        let mStartPanY = 0;
        let mIsZooming = false;
        let mIsPanning = false;

        els.previewContainer.addEventListener('click', openModal);
        els.closeModal.addEventListener('click', closeModal);
        els.modalPrev.addEventListener('click', (e) => { e.stopPropagation(); showModalPage(state.currentPage - 1); });
        els.modalNext.addEventListener('click', (e) => { e.stopPropagation(); showModalPage(state.currentPage + 1); });
        
        // Modal Background Click
        els.modal.addEventListener('click', (e) => { 
            // Close if clicking outside the image (the background) but not panning
            if (e.target === els.modal && !mIsPanning && !mIsZooming) closeModal(); 
        });

        // Touch Handlers for Zoom/Pan/Swipe
        els.modal.addEventListener('touchstart', handleModalTouchStart, {passive: false});
        els.modal.addEventListener('touchmove', handleModalTouchMove, {passive: false});
        els.modal.addEventListener('touchend', handleModalTouchEnd);

        function handleModalTouchStart(e) {
            if (e.touches.length === 2) {
                // Pinch Start
                mIsZooming = true;
                mStartDist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                mStartScale = mScale;
            } else if (e.touches.length === 1) {
                if (mScale > 1.1) {
                    // Pan Start (only if zoomed in)
                    mIsPanning = true;
                    mStartPanX = e.touches[0].pageX - mPanX;
                    mStartPanY = e.touches[0].pageY - mPanY;
                } else {
                    // Swipe Nav Start
                    mTouchStartX = e.touches[0].screenX;
                }
            }
        }

        function handleModalTouchMove(e) {
            if (mIsZooming && e.touches.length === 2) {
                e.preventDefault();
                const dist = Math.hypot(
                    e.touches[0].pageX - e.touches[1].pageX,
                    e.touches[0].pageY - e.touches[1].pageY
                );
                const scaleChange = dist / mStartDist;
                mScale = Math.max(1, Math.min(4, mStartScale * scaleChange));
                updateModalTransform();
            } else if (mIsPanning && e.touches.length === 1) {
                e.preventDefault();
                mPanX = e.touches[0].pageX - mStartPanX;
                mPanY = e.touches[0].pageY - mStartPanY;
                updateModalTransform();
            }
        }

        function handleModalTouchEnd(e) {
            mIsZooming = false;
            mIsPanning = false;
            if (e.changedTouches.length === 1 && mScale <= 1.1) {
                // End Swipe Nav logic
                const mTouchEndX = e.changedTouches[0].screenX;
                const diff = mTouchEndX - mTouchStartX;
                if (Math.abs(diff) > 50) {
                    if (diff > 0) showModalPage(state.currentPage - 1);
                    else showModalPage(state.currentPage + 1);
                }
            }
        }

        function updateModalTransform() {
            els.modalCanvas.style.transform = `translate(${mPanX}px, ${mPanY}px) scale(${mScale})`;
        }

        function resetZoom() {
            mScale = 1;
            mPanX = 0;
            mPanY = 0;
            updateModalTransform();
        }

        function openModal() {
            if (!state.pdfDoc) return;
            els.modal.classList.add('active');
            stopReader();
            showModalPage(state.currentPage);
        }

        function closeModal() { 
            els.modal.classList.remove('active'); 
            
            if (!state.words || state.words.length === 0) return;

            const currentWordObj = state.words[state.wordIndex];
            const currentWordPage = currentWordObj ? currentWordObj.page : 1;
            
            if (state.currentPage !== currentWordPage) {
                const newIndex = state.pageMap[state.currentPage] || 0;
                // Force rerender via logic
                state.lastRenderedPage = 0; 
                renderPageThumbnail(state.currentPage);
                jumpToWord(newIndex);
            }
        }

        async function showModalPage(pageNum) {
            if (pageNum < 1 || pageNum > state.pdfDoc.numPages) return;
            
            // Reset zoom when changing page
            resetZoom();

            state.currentPage = pageNum;
            
            // Update UI Counters (In Modal and Main UI)
            els.modalPageNum.textContent = `Page ${pageNum} / ${state.pdfDoc.numPages}`;
            els.currentPageNum.textContent = pageNum;

            const page = await state.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: 2.0 });

            els.modalCanvas.height = viewport.height;
            els.modalCanvas.width = viewport.width;

            const ctx = els.modalCanvas.getContext('2d');
            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
        }

        // --- Parsing & Processing ---

        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (file.type !== 'application/pdf') { alert('Invalid PDF'); return; }

            els.loader.style.display = 'flex';
            try {
                // Reset state
                state.words = [];
                state.pageMap = [];
                state.currentPage = 0; // Reset pagination state
                
                const buffer = await file.arrayBuffer();
                state.pdfDoc = await pdfjsLib.getDocument({ data: buffer }).promise;
                
                // Attempt extraction
                await extractContent(state.pdfDoc);
                
                // Success path (even if partial)
                if (state.words.length > 0) {
                    els.progressSlider.max = state.words.length - 1;
                    const total = state.words.length.toLocaleString();
                    els.totalWordsMobile.textContent = total;
                    els.totalWordsDesktop.textContent = total;
                    jumpToWord(0);
                } else {
                    throw new Error("No text found");
                }
                
                els.loader.style.display = 'none';
            } catch (err) {
                console.error(err);
                // Only alert if we found absolutely nothing
                if (state.words.length === 0) {
                    alert('Parsing failed. File might be password protected or purely scanned images.');
                }
                els.loader.style.display = 'none';
            }
        }

        async function extractContent(pdf) {
            state.words = [];
            state.pageMap = [];
            els.chapterSelect.innerHTML = '';

            let currentWordCount = 0;

            for (let i = 1; i <= pdf.numPages; i++) {
                if (i%5===0) els.loadStatus.textContent = `Page ${i}/${pdf.numPages}...`;
                state.pageMap[i] = currentWordCount;

                try {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1.0 }); // Needed for context height
                    const content = await page.getTextContent();
                    let pageWords = [];
                    let lastY = -1;
                    let lastStr = "";

                    content.items.forEach(item => {
                        const str = item.str;
                        if (!str.trim()) return;
                        
                        const tx = item.transform;
                        const x = tx[4]; const y = tx[5];
                        const w = item.width; const h = item.height || 12;

                        // --- Page Number / Header / Footer Detection ---
                        const isBottom = y < 60; // Approx 1 inch from bottom (72 DPI)
                        const isTop = y > (viewport.height - 60); 
                        const pageNumRegex = /^-?\s*(page\s*)?(\d+|[ivxlc]+)(\s*\/\s*\d+)?\s*-?$/i;
                        
                        if ((isBottom || isTop) && pageNumRegex.test(str.trim())) {
                            return; 
                        }

                        // --- Paragraph Break Detection ---
                        if (lastY !== -1) {
                             const dist = Math.abs(y - lastY);
                             if (dist > (h * 2.5) && !lastStr.trim().endsWith('-')) {
                                 pageWords.push({ text: PARA_TOKEN, page: i, x, y, w: 0, h: 0 });
                             }
                        }

                        const words = str.split(/\s+/).filter(s => s.length > 0);
                        if (words.length > 0) {
                            const charW = w / str.length;
                            let cx = x;
                            words.forEach(txt => {
                                const ww = txt.length * charW;
                                pageWords.push({ text: txt, page: i, x: cx, y, w: ww, h });
                                cx += ww + charW;
                            });
                        }
                        lastY = y;
                        lastStr = str;
                    });

                    // --- Punctuation Merge ---
                    const cleanWords = [];
                    for (let k = 0; k < pageWords.length; k++) {
                        const cur = pageWords[k];
                        if (cur.text === PARA_TOKEN) { cleanWords.push(cur); continue; }

                        const isOpenQuote = /^[“‘(\[{«]$/.test(cur.text) || 
                                            ((cur.text === '"' || cur.text === "'") && k+1 < pageWords.length && /^[a-zA-Z0-9]/.test(pageWords[k+1].text));
                        
                        if (isOpenQuote && k + 1 < pageWords.length && pageWords[k+1].text !== PARA_TOKEN) {
                             const next = pageWords[k+1];
                             next.text = cur.text + next.text;
                             next.x = cur.x; 
                             next.w += cur.w;
                             continue; 
                        }

                        const isTrailing = /^[.,;:?!…»”’')\]}]+$/.test(cur.text) || cur.text === '"' || cur.text === "'";
                        
                        if (isTrailing && cleanWords.length > 0) {
                             const prev = cleanWords[cleanWords.length - 1];
                             if (prev.text !== PARA_TOKEN) {
                                 prev.text += cur.text;
                                 prev.w += cur.w;
                                 continue;
                             }
                        }
                        cleanWords.push(cur);
                    }
                    pageWords = cleanWords;

                    // --- Merge Hyphens ---
                    const finalPageWords = [];
                    for (let j = 0; j < pageWords.length; j++) {
                        let cur = pageWords[j];
                        if (cur.text === PARA_TOKEN) { finalPageWords.push(cur); continue; }

                        if (cur.text.endsWith('-') && j+1 < pageWords.length) {
                            let next = pageWords[j+1];
                            if (next.text !== PARA_TOKEN && /^[a-z]/.test(next.text)) {
                                cur.text = cur.text.slice(0, -1) + next.text;
                                cur.w += next.w;
                                j++;
                            }
                        }
                        finalPageWords.push(cur);
                    }
                    
                    state.words.push(...finalPageWords);
                    currentWordCount += finalPageWords.length;

                } catch (err) {
                    console.warn(`Skipping page ${i} due to error`, err);
                }
            }

            // Outline
            try {
                els.loadStatus.textContent = 'Building Outline...';
                const outline = await pdf.getOutline();
                if (outline) {
                    for (const o of outline) {
                        try {
                            let dest = o.dest;
                            let pIdx = -1;
                            if (typeof dest === 'string') pIdx = await pdf.getPageIndex(dest);
                            else if (Array.isArray(dest)) pIdx = await pdf.getPageIndex(dest[0]);
                            
                            if (pIdx !== -1) {
                                addOption(o.title, state.pageMap[pIdx + 1] || 0);
                            }
                        } catch(e){}
                    }
                }
            } catch (err) {
                console.log("Outline parsing failed (non-fatal)", err);
            }
            
            if (els.chapterSelect.options.length === 0) {
                for (let i = 1; i <= pdf.numPages; i++) {
                    if (state.pageMap[i] !== undefined) {
                        addOption(`Page ${i}`, state.pageMap[i]);
                    }
                }
            }
        }

        function addOption(txt, val) {
            const o = document.createElement('option');
            o.text = txt; o.value = val;
            els.chapterSelect.add(o);
        }

        // --- Reader Engine ---

        function jumpToWord(idx) {
            state.wordIndex = Math.max(0, Math.min(idx, state.words.length - 1));
            updateDisplay();
            updateProgress();
            
            const wObj = state.words[state.wordIndex];
            if (wObj) {
                // Render page thumbnail if we are on Desktop OR in Map view on Mobile
                // AND if the page has changed since last render
                // OR if it's the very first load (currentPage is 0)
                if (state.isDesktop || state.carouselIndex === 1) {
                    if (wObj.page !== state.currentPage || state.currentPage === 0) {
                        renderPageThumbnail(wObj.page);
                    } else {
                        drawHighlight();
                    }
                } else {
                    // Just update internal state if map is hidden (mobile controls view)
                    if (wObj.page !== state.currentPage) {
                        state.currentPage = wObj.page;
                        state.lastRenderedPage = 0; // Force update next time map is shown
                    }
                }
            }
        }

        function togglePlay() {
            if (state.words.length === 0) return;
            state.isPlaying ? stopReader() : startReader();
        }

        function startReader() {
            if (state.wordIndex >= state.words.length) state.wordIndex = 0;
            state.isPlaying = true;
            els.iconPlay.classList.add('hidden');
            els.iconPause.classList.remove('hidden');
            readerLoop();
        }

        function stopReader() {
            state.isPlaying = false;
            clearTimeout(state.timeoutId);
            els.iconPlay.classList.remove('hidden');
            els.iconPause.classList.add('hidden');
        }

        function readerLoop() {
            if (!state.isPlaying || state.wordIndex >= state.words.length) {
                stopReader(); return;
            }

            const wObj = state.words[state.wordIndex];
            const baseDelay = 60000 / state.wpm;
            let factor = 1.0;

            if (wObj.text === PARA_TOKEN) {
                showParaBreak();
                state.wordIndex++;
                updateProgress();
                state.timeoutId = setTimeout(() => {
                    hideParaBreak();
                    readerLoop();
                }, baseDelay * 3);
                return;
            }

            renderRSVPWord(wObj.text);
            updateProgress();

            // Desktop/Map View Update Logic
            if (state.isDesktop || state.carouselIndex === 1) {
                if (wObj.page !== state.currentPage) renderPageThumbnail(wObj.page);
                else drawHighlight();
            } else if (wObj.page !== state.currentPage) {
                state.currentPage = wObj.page;
                state.lastRenderedPage = 0; 
            }

            // Word Length Factors
            const len = wObj.text.length;
            if (len > 7) factor = 2.5;
            else if (len < 4) factor = 0.8;
            
            // Punctuation Factors
            if (/\.['"”’)]*$/.test(wObj.text)) {
                factor += 2.0; 
            } 
            else if (/[?!]['"”’)]*$/.test(wObj.text)) {
                factor += 2.0; 
            } 
            else if (/[;:].*$/.test(wObj.text)) {
                factor *= 1.5;
            } 
            else if (/,.*$/.test(wObj.text)) {
                factor *= 1.2;
            }

            state.wordIndex++;
            state.timeoutId = setTimeout(readerLoop, baseDelay * factor);
        }

        // IMPORTANT: updateDisplay function restored here
        function updateDisplay() {
            const wordObj = state.words[state.wordIndex];
            if (!wordObj) return;
            
            if (wordObj.text === PARA_TOKEN) {
                showParaBreak();
            } else {
                hideParaBreak();
                renderRSVPWord(wordObj.text);
            }
        }

        function showParaBreak() {
            els.wordLeft.textContent = "";
            els.wordFocus.textContent = "";
            els.wordRight.textContent = "";
            els.paraIndicator.classList.remove('hidden');
        }

        function hideParaBreak() {
            els.paraIndicator.classList.add('hidden');
        }

        function renderRSVPWord(word) {
            const len = word.length;
            
            // Dynamic Font Sizing based on Device
            if (state.isDesktop) {
                // Larger fonts for desktop
                if (len > 12) {
                    els.wordDisplay.style.fontSize = "40px"; 
                } else if (len > 8) {
                    els.wordDisplay.style.fontSize = "50px"; 
                } else {
                    els.wordDisplay.style.fontSize = "60px"; 
                }
            } else {
                // Compact fonts for mobile (prevent overflow)
                if (len > 12) {
                    els.wordDisplay.style.fontSize = "27px"; 
                } else if (len > 8) {
                    els.wordDisplay.style.fontSize = "32px"; 
                } else {
                    els.wordDisplay.style.fontSize = "38px"; 
                }
            }

            // Focus Character Logic
            let focusIdx = 1; 
            
            if (len === 1) {
                focusIdx = 0; 
            } else if (len >= 7) {
                focusIdx = 2; 
            }

            if (focusIdx >= len) focusIdx = len - 1;

            els.wordLeft.textContent = word.substring(0, focusIdx);
            els.wordFocus.textContent = word.charAt(focusIdx);
            els.wordRight.textContent = word.substring(focusIdx + 1);
        }

        function updateProgress() {
            els.progressSlider.value = state.wordIndex;
            els.progressText.textContent = `${state.wordIndex + 1}/${state.words.length}`;
            if (state.wordIndex % 5 === 0) updateTimeRemaining();
        }

        function updateTimeRemaining() {
            const left = state.words.length - state.wordIndex;
            const mins = Math.ceil(left / state.wpm);
            els.timeRemaining.textContent = left > 0 ? `${mins}m left` : "Done";
        }

        // --- Thumbnail Logic ---
        
        async function renderPageThumbnail(pageNum) {
            if (!state.pdfDoc) return;
            
            // Check if we need to re-render due to resolution change (Mobile vs Desktop)
            // Or just a simple page flip
            const targetScale = state.isDesktop ? 1.5 : 0.5;
            
            // If page is same AND scale hasn't drastically changed (simple heuristic), just highlight
            // We'll store lastRenderedScale to be sure
            if (pageNum === state.lastRenderedPage && state.cachedPageImage && state.lastRenderedScale === targetScale) {
                drawHighlight(); return;
            }

            state.currentPage = pageNum;
            state.lastRenderedPage = pageNum;
            state.lastRenderedScale = targetScale;
            
            els.currentPageNum.textContent = pageNum;

            const page = await state.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: targetScale });

            els.previewCanvas.height = viewport.height;
            els.previewCanvas.width = viewport.width;

            const ctx = els.previewCanvas.getContext('2d');
            state.currentThumbnailViewport = viewport;

            await page.render({ canvasContext: ctx, viewport }).promise;
            
            createImageBitmap(els.previewCanvas).then(img => {
                state.cachedPageImage = img;
                drawHighlight();
            });
        }

        function drawHighlight() {
            if (!state.cachedPageImage || !state.currentThumbnailViewport) return;
            const ctx = els.previewCanvas.getContext('2d');
            
            ctx.clearRect(0,0, els.previewCanvas.width, els.previewCanvas.height);
            ctx.drawImage(state.cachedPageImage, 0, 0);

            const wObj = state.words[state.wordIndex];
            if (!wObj || wObj.text === PARA_TOKEN || wObj.page !== state.currentPage) return;

            const rect = state.currentThumbnailViewport.convertToViewportRectangle([
                wObj.x, wObj.y, wObj.x + wObj.w, wObj.y + wObj.h
            ]);
            
            const rx = Math.min(rect[0], rect[2]);
            const ry = Math.min(rect[1], rect[3]);
            const rw = Math.abs(rect[2] - rect[0]);
            const rh = Math.abs(rect[3] - rect[1]);

            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.fillRect(rx, ry, rw, rh);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(rx, ry, rw, rh);
        }
    </script>
</body>
</html>