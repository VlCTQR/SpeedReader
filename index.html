<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Speed Reader</title>
    <!-- Favicon -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚡</text></svg>">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&family=Inter:wght@400;600&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
        }

        /* --- SAFE AREA ADJUSTMENTS --- */
        header {
            /* Adds status bar height to top padding */
            padding-top: calc(0.75rem + env(safe-area-inset-top));
            padding-bottom: 0.75rem;
            min-height: 4rem;
        }

        #main-container {
            /* Adds home indicator height to bottom padding */
            padding-bottom: calc(1rem + env(safe-area-inset-bottom));
        }

        /* --- CAROUSEL STYLES (Top Widget) --- */
        .carousel-viewport {
            overflow: hidden;
            width: 100%;
            border-radius: 0.75rem;
            background: white;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            border: 1px solid #f3f4f6;
            position: relative;
            touch-action: pan-y; 
        }

        .carousel-track {
            display: flex;
            width: 200%; 
            transition: transform 0.3s cubic-bezier(0.25, 1, 0.5, 1);
        }

        .carousel-slide {
            width: 50%; 
            padding: 1rem;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .carousel-dots {
            position: absolute;
            bottom: 5px;
            left: 0; 
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 6px;
            pointer-events: none;
        }
        .dot {
            width: 6px; height: 6px;
            background: #d1d5db;
            border-radius: 50%;
            transition: background 0.3s;
        }
        .dot.active { background: #4f46e5; }

        /* --- READER DISPLAY --- */
        .reader-display {
            font-family: 'Roboto Mono', monospace;
            height: 240px; 
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #ffffff;
            border-radius: 1rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden; 
            padding-right: 1rem; 
            touch-action: pan-y; /* Allow vertical scroll, capture horizontal */
        }

        .focus-guide-top, .focus-guide-bottom {
            position: absolute;
            left: 30%; 
            transform: translateX(-50%);
            width: 2px;
            height: 10px;
            background-color: #e5e7eb;
            pointer-events: none;
        }
        .focus-guide-top { top: 20px; }
        .focus-guide-bottom { bottom: 20px; }

        .word-container {
            font-size: 34px; 
            font-weight: 600;
            color: #1f2937;
            display: flex;
            align-items: center;
            width: 100%;
            transition: font-size 0.1s ease-out; 
            pointer-events: none; 
        }

        .focus-char { color: #ef4444; flex-shrink: 0; }
        
        .word-left { text-align: right; width: 30%; white-space: nowrap; }
        .word-right { text-align: left; width: 70%; white-space: nowrap; }
        .para-break { color: #9ca3af; font-size: 27px; } 

        /* --- PREVIEW WIDGET --- */
        .page-preview-wrapper {
            width: 100%;
            background: #e5e7eb;
            border-radius: 0.5rem;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            cursor: pointer;
            z-index: 10; 
        }
        
        /* Updated Expand Hint to ensure clickability */
        .expand-hint {
            position: absolute; inset: 0;
            background: rgba(0,0,0,0.1);
            display: flex; align-items: center; justify-content: center;
            color: white; opacity: 0;
            transition: opacity 0.2s; 
            pointer-events: none; /* Icon allows click through to wrapper */
        }
        .page-preview-wrapper:hover .expand-hint { opacity: 1; }

        /* Highlight span in Text Mode */
        .text-highlight {
            background-color: rgba(239, 68, 68, 0.3); 
            border-bottom: 2px solid #ef4444;
        }

        /* --- MODAL --- */
        #page-modal {
            display: none;
            position: fixed; inset: 0; z-index: 60;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(5px);
            align-items: center; justify-content: center;
            touch-action: none; 
            overflow: hidden;
        }
        #page-modal.active { display: flex; }
        
        .modal-nav-btn {
            position: absolute; top: 50%; transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            color: white; border: 1px solid rgba(255,255,255,0.4);
            padding: 1rem; border-radius: 50%; cursor: pointer; z-index: 90;
            transition: background 0.2s;
        }
        .modal-nav-btn:hover { background: rgba(255, 255, 255, 0.3); }
        .modal-prev { left: 20px; }
        .modal-next { right: 20px; }

        #close-modal { z-index: 100; }
        #modal-canvas { transform-origin: center center; transition: transform 0.1s ease-out; }

        /* Loader */
        #loader {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95); z-index: 50;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
    </style>
</head>
<body class="text-gray-800">

    <!-- Loading Overlay -->
    <div id="loader">
        <div class="animate-spin rounded-full h-12 w-12 border-t-4 border-b-4 border-indigo-600 mb-4"></div>
        <h2 class="text-lg font-semibold text-gray-700">Processing...</h2>
        <p id="loading-status" class="text-sm text-gray-500 mt-2">Initializing...</p>
    </div>

    <!-- Full Screen Page Modal (PDF Only) -->
    <div id="page-modal">
        <button class="absolute top-6 right-6 text-white text-5xl font-light hover:text-gray-300 active:text-gray-400 drop-shadow-md leading-none w-12 h-12 flex items-center justify-center" id="close-modal">&times;</button>
        <div class="absolute bottom-6 left-1/2 -translate-x-1/2 bg-black/50 backdrop-blur-sm text-white px-4 py-1.5 rounded-full text-sm font-mono z-50 pointer-events-none" id="modal-page-num">Page -</div>
        <button class="modal-nav-btn modal-prev" id="modal-prev-btn"><i class="fa-solid fa-chevron-left"></i></button>
        <div class="relative w-full h-full p-2 flex items-center justify-center pointer-events-none">
            <canvas id="modal-canvas" class="max-w-full max-h-full object-contain shadow-2xl bg-white pointer-events-auto"></canvas>
        </div>
        <button class="modal-nav-btn modal-next" id="modal-next-btn"><i class="fa-solid fa-chevron-right"></i></button>
    </div>

    <!-- Hidden File Input -->
    <input id="file-upload" type="file" accept="application/pdf" class="hidden">

    <!-- Header -->
    <header class="bg-white shadow-sm px-3 flex justify-between items-center z-10 shrink-0">
        <div class="flex items-center gap-2">
            <i class="fa-solid fa-bolt text-yellow-500 text-xl"></i>
            <h1 class="text-lg font-bold tracking-tight text-gray-800">Speed<span class="text-indigo-600">Reader</span></h1>
        </div>
        <div>
            <!-- Reset / Load New Button -->
            <button id="btn-reset-all" class="cursor-pointer text-gray-500 hover:text-indigo-600 px-3 py-2 rounded-lg text-sm flex items-center gap-2 transition">
                <i class="fa-solid fa-folder-open"></i>
                <span>Load New</span>
            </button>
        </div>
    </header>

    <!-- Main Content Area -->
    <main id="main-container" class="flex-grow flex flex-col w-full max-w-7xl mx-auto px-4 pt-4 gap-4 overflow-y-auto lg:overflow-hidden">
        
        <!-- Mobile Carousel Structure -->
        <div id="mobile-carousel-wrapper" class="carousel-viewport lg:hidden shrink-0">
            <div class="carousel-track" id="carousel-track">
                <div class="carousel-slide" id="slide-1"></div> <!-- Controls -->
                <div class="carousel-slide" id="slide-2"></div> <!-- Preview/Map -->
            </div>
            <div class="carousel-dots" id="carousel-dots-container">
                <div class="dot active" id="dot-0"></div>
                <div class="dot" id="dot-1"></div>
            </div>
        </div>

        <!-- Desktop Grid Container -->
        <div id="desktop-grid" class="hidden lg:grid grid-cols-2 gap-6 h-full min-h-0">
            <div id="desktop-left" class="flex flex-col gap-4 h-full min-h-0 overflow-y-auto"></div>
            <div id="desktop-right" class="flex flex-col items-center justify-center bg-gray-200 rounded-xl p-6 shadow-inner h-full min-h-0 relative overflow-hidden"></div>
        </div>

        <!-- CONTENT GROUPS -->
        
        <!-- 1. Controls Group -->
        <div id="controls-group" class="flex flex-col w-full shrink-0">
            <div id="controls-card-inner" class="flex flex-col gap-2 w-full h-full justify-between">
                <div id="jump-to-container">
                    <label class="text-xs font-bold text-gray-400 uppercase">Jump To</label>
                    <select id="chapter-select" class="w-full bg-gray-50 border border-gray-200 text-gray-700 text-sm rounded-lg p-2 mt-1">
                        <option value="" disabled selected>Load Content First</option>
                    </select>
                </div>
                <div>
                    <div class="flex justify-between items-end mb-1">
                        <label class="text-xs font-bold text-gray-400 uppercase">Speed</label>
                        <span class="text-xs text-gray-500 font-mono"><span id="wpm-display">300</span> WPM</span>
                    </div>
                    <input type="range" id="wpm-slider" min="50" max="1000" step="10" value="300" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600">
                </div>
                <div class="flex justify-between text-xs text-gray-400 pt-1 border-t border-gray-100 lg:hidden">
                     <span>Words: <span id="total-words-mobile" class="text-gray-600 font-semibold">0</span></span>
                     <span id="swipe-map-hint" class="text-indigo-500 font-semibold flex items-center gap-1">Swipe for Map <i class="fa-solid fa-arrow-right"></i></span>
                </div>
                <div class="hidden lg:block text-xs text-gray-400 pt-1">
                    Total Words: <span id="total-words-desktop" class="text-gray-600 font-bold">0</span>
                </div>
            </div>
        </div>

        <!-- 2. Preview Group (Right Panel Content) -->
        <div id="preview-group" class="flex flex-col h-full items-center justify-center w-full h-full">
            
            <!-- STATE: EMPTY / SELECTION -->
            <div id="source-selection" class="flex flex-col gap-4 items-center justify-center w-full h-full">
                <button id="btn-select-pdf" class="flex flex-col items-center justify-center bg-white hover:bg-indigo-50 border-2 border-dashed border-indigo-200 hover:border-indigo-400 rounded-xl p-8 w-64 transition group">
                    <i class="fa-solid fa-file-pdf text-4xl text-indigo-500 mb-3 group-hover:scale-110 transition-transform"></i>
                    <span class="font-bold text-gray-700">Upload PDF</span>
                    <span class="text-xs text-gray-400 mt-1">Standard Format</span>
                </button>
                <div class="text-gray-400 font-mono text-xs">- OR -</div>
                <button id="btn-select-text" class="flex flex-col items-center justify-center bg-white hover:bg-emerald-50 border-2 border-dashed border-emerald-200 hover:border-emerald-400 rounded-xl p-8 w-64 transition group">
                    <i class="fa-solid fa-align-left text-4xl text-emerald-500 mb-3 group-hover:scale-110 transition-transform"></i>
                    <span class="font-bold text-gray-700">Paste Text</span>
                    <span class="text-xs text-gray-400 mt-1">Direct Input</span>
                </button>
            </div>

            <!-- STATE: PDF VIEW -->
            <div id="pdf-view-container" class="hidden flex flex-col w-full h-full">
                <div class="w-full flex justify-between items-center mb-1 px-1 lg:mb-2 shrink-0">
                    <label class="text-xs font-bold text-gray-400 uppercase">Current Page Location</label>
                    <span class="text-xs font-mono text-gray-500">Page <span id="current-page-num">-</span></span>
                </div>
                <div class="page-preview-wrapper h-[120px] lg:h-full lg:w-full lg:flex-grow" id="preview-container">
                    <canvas id="preview-canvas" class="h-full w-full object-contain"></canvas>
                    <div class="expand-hint"><i class="fa-solid fa-expand text-2xl drop-shadow-md"></i></div>
                </div>
            </div>

            <!-- STATE: TEXT EDIT VIEW -->
            <div id="text-view-container" class="hidden w-full h-full bg-white rounded-lg shadow-inner p-4 overflow-y-auto border border-gray-200 font-mono text-sm leading-relaxed whitespace-pre-wrap outline-none focus:ring-2 ring-indigo-100" contenteditable="true">
                <!-- Text content goes here -->
            </div>
        </div>

        <!-- 3. Reader Card -->
        <div id="reader-group" class="w-full shrink-0">
            <div class="w-full reader-display relative" id="reader-card">
                
                <!-- RSVP Display Layer -->
                <div id="rsvp-layer" class="w-full h-full absolute inset-0 flex items-center justify-center">
                    <div class="focus-guide-top"></div>
                    <div id="word-display" class="word-container">
                        <span class="word-left" id="word-left">Load</span>
                        <span class="focus-char" id="word-focus">P</span>
                        <span class="word-right" id="word-right">DF</span>
                    </div>
                    <div id="para-indicator" class="hidden absolute top-4 right-4 text-gray-300 text-4xl">¶</div>
                    <div class="focus-guide-bottom"></div>
                    <!-- Swipe Hint for Mobile Text Mode -->
                    <div id="swipe-edit-hint" class="hidden absolute bottom-2 w-full text-center text-xs text-gray-300 font-medium tracking-wide pointer-events-none lg:hidden">
                        Swipe Right to Edit <i class="fa-solid fa-pen ml-1"></i>
                    </div>
                </div>

                <!-- Mobile Input Overlay (Shown when empty on mobile) -->
                <div id="mobile-input-overlay" class="hidden absolute inset-0 bg-white z-20 flex flex-col p-4">
                    <textarea id="mobile-text-input" class="w-full flex-grow p-3 bg-gray-50 rounded border border-gray-200 resize-none text-sm font-mono focus:outline-none focus:border-indigo-500" placeholder="Paste your text here..."></textarea>
                    <div class="flex gap-2 mt-2 shrink-0">
                        <button id="btn-mobile-upload-pdf" class="flex-1 bg-gray-100 text-gray-600 py-2 rounded font-semibold text-sm hover:bg-gray-200">
                            <i class="fa-solid fa-file-pdf mr-1"></i> PDF
                        </button>
                        <button id="btn-mobile-start-text" class="flex-1 bg-indigo-600 text-white py-2 rounded font-semibold text-sm hover:bg-indigo-700">
                            Start Reading
                        </button>
                    </div>
                </div>

            </div>
        </div>

        <!-- 4. Progress Bar -->
        <div id="progress-group" class="w-full shrink-0">
            <div class="flex justify-between text-xs text-gray-500 font-mono px-1 mb-1">
                <span id="progress-text">0 / 0</span>
                <span id="time-remaining">0m left</span>
            </div>
            <input type="range" id="progress-slider" min="0" max="100" value="0" class="w-full h-2 bg-gray-300 rounded-lg appearance-none cursor-pointer accent-indigo-600">
        </div>

        <!-- 5. Playback Controls -->
        <div id="playback-group" class="flex gap-8 items-center justify-center pb-2 shrink-0">
            <button id="btn-restart" class="text-gray-400 hover:text-gray-600 active:scale-95 transition p-2" title="Restart">
                <i class="fa-solid fa-rotate-left text-2xl"></i>
            </button>

            <button id="btn-play-pause" class="bg-indigo-600 active:bg-indigo-800 text-white w-16 h-16 rounded-full shadow-lg flex items-center justify-center transition transform active:scale-95">
                <i class="fa-solid fa-play text-2xl pl-1" id="icon-play"></i>
                <i class="fa-solid fa-pause text-2xl hidden" id="icon-pause"></i>
            </button>

            <button id="btn-rewind" class="text-gray-400 hover:text-gray-600 active:scale-95 transition p-2" title="Back 10">
                <i class="fa-solid fa-backward text-2xl"></i>
            </button>
        </div>

    </main>

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const state = {
            mode: 'empty', // 'empty', 'pdf', 'text'
            pdfDoc: null,
            words: [],          // Array of {text, page, index}
            wordSpans: [],      // Array of span elements for Text Mode highlighting
            wordIndex: 0,
            isPlaying: false,
            wpm: 300,
            timeoutId: null,
            pageMap: [],
            currentPage: 0,
            lastRenderedPage: 0,
            cachedPageImage: null,
            carouselIndex: 0,
            isDesktop: false
        };

        const PARA_TOKEN = "___PARA___";

        const els = {
            mainContainer: document.getElementById('main-container'),
            // Layout
            desktopLeft: document.getElementById('desktop-left'),
            desktopRight: document.getElementById('desktop-right'),
            mobileCarousel: document.getElementById('mobile-carousel-wrapper'),
            desktopGrid: document.getElementById('desktop-grid'),
            slide1: document.getElementById('slide-1'),
            slide2: document.getElementById('slide-2'),
            // Groups
            controlsGroup: document.getElementById('controls-group'),
            controlsCardInner: document.getElementById('controls-card-inner'),
            jumpToContainer: document.getElementById('jump-to-container'), 
            swipeMapHint: document.getElementById('swipe-map-hint'), // Added
            swipeEditHint: document.getElementById('swipe-edit-hint'), // Added
            previewGroup: document.getElementById('preview-group'),
            readerGroup: document.getElementById('reader-group'),
            progressGroup: document.getElementById('progress-group'),
            playbackGroup: document.getElementById('playback-group'),
            // Selection UI
            sourceSelection: document.getElementById('source-selection'),
            btnSelectPdf: document.getElementById('btn-select-pdf'),
            btnSelectText: document.getElementById('btn-select-text'),
            btnResetAll: document.getElementById('btn-reset-all'),
            // Inputs
            fileInput: document.getElementById('file-upload'),
            textViewContainer: document.getElementById('text-view-container'),
            pdfViewContainer: document.getElementById('pdf-view-container'),
            mobileInputOverlay: document.getElementById('mobile-input-overlay'),
            mobileTextInput: document.getElementById('mobile-text-input'),
            btnMobileUploadPdf: document.getElementById('btn-mobile-upload-pdf'),
            btnMobileStartText: document.getElementById('btn-mobile-start-text'),
            
            // Common
            loader: document.getElementById('loader'),
            loadStatus: document.getElementById('loading-status'),
            chapterSelect: document.getElementById('chapter-select'),
            wpmSlider: document.getElementById('wpm-slider'),
            wpmDisplay: document.getElementById('wpm-display'),
            // Reader
            rsvpLayer: document.getElementById('rsvp-layer'),
            wordDisplay: document.getElementById('word-display'),
            wordLeft: document.getElementById('word-left'),
            wordFocus: document.getElementById('word-focus'),
            wordRight: document.getElementById('word-right'),
            paraIndicator: document.getElementById('para-indicator'),
            // Controls
            progressText: document.getElementById('progress-text'),
            timeRemaining: document.getElementById('time-remaining'),
            progressSlider: document.getElementById('progress-slider'),
            totalWordsMobile: document.getElementById('total-words-mobile'),
            totalWordsDesktop: document.getElementById('total-words-desktop'),
            btnPlayPause: document.getElementById('btn-play-pause'),
            iconPlay: document.getElementById('icon-play'),
            iconPause: document.getElementById('icon-pause'),
            btnRestart: document.getElementById('btn-restart'),
            btnRewind: document.getElementById('btn-rewind'),
            // Preview
            previewCanvas: document.getElementById('preview-canvas'),
            previewContainer: document.getElementById('preview-container'),
            currentPageNum: document.getElementById('current-page-num'),
            // Carousel Nav
            carouselTrack: document.getElementById('carousel-track'),
            carouselDots: document.getElementById('carousel-dots-container'), // Added
            dot0: document.getElementById('dot-0'),
            dot1: document.getElementById('dot-1'),
            // Modal
            modal: document.getElementById('page-modal'),
            modalCanvas: document.getElementById('modal-canvas'),
            closeModal: document.getElementById('close-modal'),
            modalPrev: document.getElementById('modal-prev-btn'),
            modalNext: document.getElementById('modal-next-btn'),
            modalPageNum: document.getElementById('modal-page-num')
        };

        // --- Initialization & Layout ---

        function init() {
            handleResize();
            resetState();
        }

        function resetState() {
            state.mode = 'empty';
            state.words = [];
            state.wordIndex = 0;
            state.pageMap = [];
            state.pdfDoc = null;
            state.wordSpans = [];
            stopReader();
            
            // UI Resets
            els.chapterSelect.innerHTML = '<option value="" disabled selected>Load Content First</option>';
            els.wordLeft.textContent = "Load";
            els.wordFocus.textContent = "P";
            els.wordRight.textContent = "DF/Text";
            els.progressSlider.value = 0;
            els.totalWordsMobile.textContent = "0";
            els.totalWordsDesktop.textContent = "0";
            els.mobileTextInput.value = "";
            els.textViewContainer.innerHTML = "";
            
            // View Switching
            updateViewsForMode();
        }

        function updateViewsForMode() {
            // Hide all specialized views first
            els.sourceSelection.classList.add('hidden');
            els.pdfViewContainer.classList.add('hidden');
            els.textViewContainer.classList.add('hidden');
            els.mobileInputOverlay.classList.add('hidden');
            els.rsvpLayer.classList.remove('hidden');
            
            // Default: Show Jump To & Map Hint, Hide Edit Hint, Show Dots
            els.jumpToContainer.classList.remove('hidden');
            if (els.swipeMapHint) els.swipeMapHint.classList.remove('hidden');
            if (els.swipeEditHint) els.swipeEditHint.classList.add('hidden');
            if (els.carouselDots) els.carouselDots.classList.remove('hidden');

            if (state.mode === 'empty') {
                if (state.isDesktop) {
                    els.sourceSelection.classList.remove('hidden');
                } else {
                    els.mobileInputOverlay.classList.remove('hidden');
                    // On mobile empty, we might hide RSVP layer to show input clearly
                    els.rsvpLayer.classList.add('hidden');
                }
            } else if (state.mode === 'pdf') {
                if (state.isDesktop || state.carouselIndex === 1) {
                    els.pdfViewContainer.classList.remove('hidden');
                }
            } else if (state.mode === 'text') {
                // Hide Jump To for text mode
                els.jumpToContainer.classList.add('hidden');
                
                // Toggle Hints for Mobile Text Mode
                if (els.swipeMapHint) els.swipeMapHint.classList.add('hidden');
                if (!state.isDesktop && els.swipeEditHint) els.swipeEditHint.classList.remove('hidden');
                
                // Hide Dots since carousel is locked
                if (els.carouselDots) els.carouselDots.classList.add('hidden');

                if (state.isDesktop) {
                    els.textViewContainer.classList.remove('hidden');
                }
                
                if (!state.isDesktop && state.carouselIndex === 1) {
                     els.textViewContainer.classList.remove('hidden');
                }
            }
        }

        // --- Desktop Selection Handlers ---
        els.btnSelectPdf.addEventListener('click', () => els.fileInput.click());
        els.btnSelectText.addEventListener('click', () => {
            // Switch to Text Edit Mode
            state.mode = 'text';
            updateViewsForMode();
            els.textViewContainer.focus(); // Focus editable div
            // Add placeholder behavior via CSS or JS if needed, but basic is fine
            els.textViewContainer.innerText = "Paste your text here...";
        });

        // --- Mobile Selection Handlers ---
        els.btnMobileUploadPdf.addEventListener('click', () => els.fileInput.click());
        els.btnMobileStartText.addEventListener('click', () => {
            const text = els.mobileTextInput.value;
            if (!text.trim()) return;
            processRawText(text);
        });

        // --- Common Handlers ---
        els.btnResetAll.addEventListener('click', resetState);
        els.fileInput.addEventListener('change', handleFileUpload);
        
        // Text Edit Updates (Desktop) - FIXED: Don't re-render spans on input to preserve cursor
        els.textViewContainer.addEventListener('input', () => {
            // Update internal state only
            clearTimeout(state.textDebounce);
            state.textDebounce = setTimeout(() => {
                processRawText(els.textViewContainer.innerText, true);
            }, 1000);
        });

        // Re-render spans on blur to enable highlighting
        els.textViewContainer.addEventListener('blur', () => {
            if (state.words.length > 0) {
                renderTextSpans(state.words.map(w => w.text));
            }
        });

        // --- Data Processing ---

        function processRawText(text, isLiveUpdate = false) {
            // 1. Tokenize
            const tokens = text.split(/\s+/).filter(w => w.length > 0);
            
            if (tokens.length === 0) return;

            state.words = tokens.map((t, i) => ({ text: t, page: 1, index: i }));
            state.mode = 'text';
            
            // 2. Setup Highlighting (Only useful for Desktop/TextView)
            if (state.isDesktop || els.textViewContainer.offsetParent !== null) {
                // FIXED: Only render spans if NOT currently typing (focus) or if forced
                if (!isLiveUpdate || document.activeElement !== els.textViewContainer) {
                    renderTextSpans(tokens);
                }
            }

            // 3. Update Stats
            els.progressSlider.max = Math.max(0, state.words.length - 1);
            const total = state.words.length.toLocaleString();
            els.totalWordsMobile.textContent = total;
            els.totalWordsDesktop.textContent = total;

            if (!isLiveUpdate) {
                jumpToWord(0);
                updateViewsForMode();
            }
        }

        function renderTextSpans(tokens) {
            els.textViewContainer.innerHTML = '';
            state.wordSpans = [];
            
            tokens.forEach((word, idx) => {
                const span = document.createElement('span');
                span.textContent = word + ' ';
                span.dataset.idx = idx;
                els.textViewContainer.appendChild(span);
                state.wordSpans.push(span);
            });
        }

        async function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            if (file.type !== 'application/pdf') { alert('Invalid PDF'); return; }

            els.loader.style.display = 'flex';
            try {
                resetState();
                state.mode = 'pdf';
                const buffer = await file.arrayBuffer();
                state.pdfDoc = await pdfjsLib.getDocument({ data: buffer }).promise;
                await extractPdfContent(state.pdfDoc);
                
                if (state.words.length > 0) {
                    els.progressSlider.max = state.words.length - 1;
                    const total = state.words.length.toLocaleString();
                    els.totalWordsMobile.textContent = total;
                    els.totalWordsDesktop.textContent = total;
                    jumpToWord(0);
                    updateViewsForMode();
                } else {
                    throw new Error("No text found");
                }
                els.loader.style.display = 'none';
            } catch (err) {
                console.error(err);
                alert('Parsing failed.');
                els.loader.style.display = 'none';
                resetState();
            }
        }

        async function extractPdfContent(pdf) {
            // (Same extraction logic as previous correct version)
            state.words = [];
            state.pageMap = [];
            els.chapterSelect.innerHTML = '';
            let currentWordCount = 0;

            for (let i = 1; i <= pdf.numPages; i++) {
                if (i%5===0) els.loadStatus.textContent = `Page ${i}/${pdf.numPages}...`;
                state.pageMap[i] = currentWordCount;
                try {
                    const page = await pdf.getPage(i);
                    const viewport = page.getViewport({ scale: 1.0 });
                    const content = await page.getTextContent();
                    let pageWords = [];
                    let lastY = -1;
                    let lastStr = "";

                    content.items.forEach(item => {
                        const str = item.str;
                        if (!str.trim()) return;
                        const tx = item.transform;
                        const x = tx[4]; const y = tx[5];
                        const w = item.width; const h = item.height || 12;

                        // --- Header / Footer Detection (Updated) ---
                        // Standard papers usually have headers/footers within the top/bottom 50-60pts.
                        // We skip ANY text in these zones to avoid reading chapter titles, sources, or page numbers.
                        // y=0 is the bottom of the page in PDF coordinates.
                        const marginThreshold = 55; 
                        const isBottom = y < marginThreshold; 
                        const isTop = y > (viewport.height - marginThreshold); 
                        
                        if (isBottom || isTop) {
                            return; // Skip headers and footers completely
                        }

                        // --- Paragraph Break Detection ---
                        if (lastY !== -1) {
                             const dist = Math.abs(y - lastY);
                             if (dist > (h * 2.5) && !lastStr.trim().endsWith('-')) {
                                 pageWords.push({ text: PARA_TOKEN, page: i, x, y, w: 0, h: 0 });
                             }
                        }

                        const words = str.split(/\s+/).filter(s => s.length > 0);
                        if (words.length > 0) {
                            const charW = w / str.length;
                            let cx = x;
                            words.forEach(txt => {
                                const ww = txt.length * charW;
                                pageWords.push({ text: txt, page: i, x: cx, y, w: ww, h });
                                cx += ww + charW;
                            });
                        }
                        lastY = y;
                        lastStr = str;
                    });

                    // Punctuation Merge
                    const cleanWords = [];
                    for (let k = 0; k < pageWords.length; k++) {
                        const cur = pageWords[k];
                        if (cur.text === PARA_TOKEN) { cleanWords.push(cur); continue; }
                        const isOpenQuote = /^[“‘(\[{«]$/.test(cur.text) || ((cur.text === '"' || cur.text === "'") && k+1 < pageWords.length && /^[a-zA-Z0-9]/.test(pageWords[k+1].text));
                        if (isOpenQuote && k + 1 < pageWords.length && pageWords[k+1].text !== PARA_TOKEN) {
                             const next = pageWords[k+1];
                             next.text = cur.text + next.text;
                             next.x = cur.x; next.w += cur.w;
                             continue; 
                        }
                        const isTrailing = /^[.,;:?!…»”’')\]}]+$/.test(cur.text) || cur.text === '"' || cur.text === "'";
                        if (isTrailing && cleanWords.length > 0) {
                             const prev = cleanWords[cleanWords.length - 1];
                             if (prev.text !== PARA_TOKEN) {
                                 prev.text += cur.text;
                                 prev.w += cur.w;
                                 continue;
                             }
                        }
                        cleanWords.push(cur);
                    }
                    pageWords = cleanWords;

                    // Hyphen Merge
                    const finalPageWords = [];
                    for (let j = 0; j < pageWords.length; j++) {
                        let cur = pageWords[j];
                        if (cur.text === PARA_TOKEN) { finalPageWords.push(cur); continue; }
                        if (cur.text.endsWith('-') && j+1 < pageWords.length) {
                            let next = pageWords[j+1];
                            if (next.text !== PARA_TOKEN && /^[a-z]/.test(next.text)) {
                                cur.text = cur.text.slice(0, -1) + next.text;
                                cur.w += next.w;
                                j++;
                            }
                        }
                        finalPageWords.push(cur);
                    }
                    state.words.push(...finalPageWords);
                    currentWordCount += finalPageWords.length;
                } catch (err) {}
            }

            // Outline
            try {
                const outline = await pdf.getOutline();
                if (outline) {
                    for (const o of outline) {
                        try {
                            let dest = o.dest;
                            let pIdx = -1;
                            if (typeof dest === 'string') pIdx = await pdf.getPageIndex(dest);
                            else if (Array.isArray(dest)) pIdx = await pdf.getPageIndex(dest[0]);
                            if (pIdx !== -1) addOption(o.title, state.pageMap[pIdx + 1] || 0);
                        } catch(e){}
                    }
                }
            } catch (err) {}
            if (els.chapterSelect.options.length === 0) {
                for (let i = 1; i <= pdf.numPages; i++) {
                    if (state.pageMap[i] !== undefined) addOption(`Page ${i}`, state.pageMap[i]);
                }
            }
        }

        function addOption(txt, val) {
            const o = document.createElement('option');
            o.text = txt; o.value = val;
            els.chapterSelect.add(o);
        }

        // --- Reader Engine ---

        function jumpToWord(idx) {
            state.wordIndex = Math.max(0, Math.min(idx, state.words.length - 1));
            updateDisplay();
            updateProgress();
            
            // Update Visuals based on mode
            const wObj = state.words[state.wordIndex];
            if (!wObj) return;

            if (state.mode === 'pdf') {
                if (state.isDesktop || state.carouselIndex === 1) {
                    if (wObj.page !== state.currentPage || state.currentPage === 0) {
                        renderPageThumbnail(wObj.page);
                    } else {
                        drawHighlight();
                    }
                } else {
                    if (wObj.page !== state.currentPage) {
                        state.currentPage = wObj.page;
                        state.lastRenderedPage = 0;
                    }
                }
            } else if (state.mode === 'text') {
                // Text Mode Highlight
                highlightTextWord(state.wordIndex);
            }
        }

        function highlightTextWord(idx) {
            // Remove old
            const old = els.textViewContainer.querySelector('.text-highlight');
            if (old) old.classList.remove('text-highlight');
            
            // Add new - FIXED: Check bounds safely
            if (state.wordSpans && state.wordSpans[idx]) {
                const span = state.wordSpans[idx];
                span.classList.add('text-highlight');
                // Scroll into view
                const containerRect = els.textViewContainer.getBoundingClientRect();
                const spanRect = span.getBoundingClientRect();
                if (spanRect.top < containerRect.top || spanRect.bottom > containerRect.bottom) {
                    span.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }
        }

        // --- Standard Playback Logic (Shared) ---
        function togglePlay() {
            if (state.words.length === 0) return;
            state.isPlaying ? stopReader() : startReader();
        }
        function startReader() {
            if (state.wordIndex >= state.words.length) state.wordIndex = 0;
            state.isPlaying = true;
            els.iconPlay.classList.add('hidden');
            els.iconPause.classList.remove('hidden');
            readerLoop();
        }
        function stopReader() {
            state.isPlaying = false;
            clearTimeout(state.timeoutId);
            els.iconPlay.classList.remove('hidden');
            els.iconPause.classList.add('hidden');
        }
        function readerLoop() {
            if (!state.isPlaying || state.wordIndex >= state.words.length) { stopReader(); return; }
            const wObj = state.words[state.wordIndex];
            const baseDelay = 60000 / state.wpm;
            let factor = 1.0;

            if (wObj.text === PARA_TOKEN) {
                showParaBreak();
                state.wordIndex++;
                updateProgress();
                state.timeoutId = setTimeout(() => { hideParaBreak(); readerLoop(); }, baseDelay * 3);
                return;
            }

            renderRSVPWord(wObj.text);
            updateProgress();
            
            // Update previews
            if (state.mode === 'pdf' && (state.isDesktop || state.carouselIndex === 1)) {
                if (wObj.page !== state.currentPage) renderPageThumbnail(wObj.page);
                else drawHighlight();
            } else if (state.mode === 'text' && (state.isDesktop || state.carouselIndex === 1)) {
                highlightTextWord(state.wordIndex);
            }

            // Duration Factors
            const len = wObj.text.length;
            if (len > 7) factor = 2.5; else if (len < 4) factor = 0.8;
            if (/\.['"”’)]*$/.test(wObj.text) || /[?!]['"”’)]*$/.test(wObj.text)) factor += 2.0;
            else if (/[;:].*$/.test(wObj.text)) factor *= 1.5;
            else if (/,.*$/.test(wObj.text)) factor *= 1.2;

            state.wordIndex++;
            state.timeoutId = setTimeout(readerLoop, baseDelay * factor);
        }

        function updateDisplay() {
            const wordObj = state.words[state.wordIndex];
            if (!wordObj) return;
            if (wordObj.text === PARA_TOKEN) showParaBreak();
            else { hideParaBreak(); renderRSVPWord(wordObj.text); }
        }
        function showParaBreak() {
            els.wordLeft.textContent = ""; els.wordFocus.textContent = ""; els.wordRight.textContent = "";
            els.paraIndicator.classList.remove('hidden');
        }
        function hideParaBreak() { els.paraIndicator.classList.add('hidden'); }
        function renderRSVPWord(word) {
            const len = word.length;
            
            if (state.isDesktop) {
                // Desktop: 24px if len >= 16, 27px if len >= 12, else 32px
                if (len >= 16) els.wordDisplay.style.fontSize = "24px";
                else if (len >= 12) els.wordDisplay.style.fontSize = "27px";
                else els.wordDisplay.style.fontSize = "32px";
            } else {
                // Mobile: 24px if len > 12, 27px if len > 8, else 32px
                if (len > 12) els.wordDisplay.style.fontSize = "24px"; 
                else if (len > 8) els.wordDisplay.style.fontSize = "27px"; 
                else els.wordDisplay.style.fontSize = "32px";
            }

            let focusIdx = 1; 
            if (len === 1) focusIdx = 0; else if (len >= 7) focusIdx = 2;
            if (focusIdx >= len) focusIdx = len - 1;
            els.wordLeft.textContent = word.substring(0, focusIdx);
            els.wordFocus.textContent = word.charAt(focusIdx);
            els.wordRight.textContent = word.substring(focusIdx + 1);
        }
        function updateProgress() {
            els.progressSlider.value = state.wordIndex;
            els.progressText.textContent = `${state.wordIndex + 1}/${state.words.length}`;
            if (state.wordIndex % 5 === 0) updateTimeRemaining();
        }
        function updateTimeRemaining() {
            const left = state.words.length - state.wordIndex;
            const mins = Math.ceil(left / state.wpm);
            els.timeRemaining.textContent = left > 0 ? `${mins}m left` : "Done";
        }

        // --- Thumbnail & Layout Logic ---
        
        async function renderPageThumbnail(pageNum) {
            if (!state.pdfDoc || state.mode !== 'pdf') return;
            const targetScale = state.isDesktop ? 1.5 : 0.5;
            if (pageNum === state.lastRenderedPage && state.cachedPageImage && state.lastRenderedScale === targetScale) {
                drawHighlight(); return;
            }
            state.currentPage = pageNum;
            state.lastRenderedPage = pageNum;
            state.lastRenderedScale = targetScale;
            els.currentPageNum.textContent = pageNum;
            const page = await state.pdfDoc.getPage(pageNum);
            const viewport = page.getViewport({ scale: targetScale });
            els.previewCanvas.height = viewport.height;
            els.previewCanvas.width = viewport.width;
            const ctx = els.previewCanvas.getContext('2d');
            state.currentThumbnailViewport = viewport;
            await page.render({ canvasContext: ctx, viewport }).promise;
            createImageBitmap(els.previewCanvas).then(img => {
                state.cachedPageImage = img;
                drawHighlight();
            });
        }

        function drawHighlight() {
            if (!state.cachedPageImage || !state.currentThumbnailViewport || state.mode !== 'pdf') return;
            const ctx = els.previewCanvas.getContext('2d');
            ctx.clearRect(0,0, els.previewCanvas.width, els.previewCanvas.height);
            ctx.drawImage(state.cachedPageImage, 0, 0);
            const wObj = state.words[state.wordIndex];
            if (!wObj || wObj.text === PARA_TOKEN || wObj.page !== state.currentPage) return;
            const rect = state.currentThumbnailViewport.convertToViewportRectangle([
                wObj.x, wObj.y, wObj.x + wObj.w, wObj.y + wObj.h
            ]);
            const rx = Math.min(rect[0], rect[2]);
            const ry = Math.min(rect[1], rect[3]);
            const rw = Math.abs(rect[2] - rect[0]);
            const rh = Math.abs(rect[3] - rect[1]);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)';
            ctx.fillRect(rx, ry, rw, rh);
            ctx.strokeStyle = 'red';
            ctx.lineWidth = 2;
            ctx.strokeRect(rx, ry, rw, rh);
        }

        function handleResize() {
            const isDesktopNow = window.innerWidth >= 1024;
            if (isDesktopNow !== state.isDesktop || !state.layoutInitialized) {
                state.isDesktop = isDesktopNow;
                state.layoutInitialized = true;
                if (state.isDesktop) {
                    els.desktopGrid.classList.remove('hidden');
                    els.mobileCarousel.classList.add('hidden');
                    els.controlsCardInner.classList.add('bg-white', 'p-4', 'rounded-xl', 'shadow-sm', 'border', 'border-gray-100');
                    els.controlsGroup.classList.remove('h-full'); 
                    els.desktopLeft.appendChild(els.controlsGroup);
                    els.desktopLeft.appendChild(els.readerGroup);
                    els.desktopLeft.appendChild(els.progressGroup);
                    els.desktopLeft.appendChild(els.playbackGroup);
                    els.desktopRight.appendChild(els.previewGroup);
                } else {
                    els.desktopGrid.classList.add('hidden');
                    els.mobileCarousel.classList.remove('hidden');
                    els.controlsCardInner.classList.remove('bg-white', 'p-4', 'rounded-xl', 'shadow-sm', 'border', 'border-gray-100');
                    els.controlsGroup.classList.add('h-full');
                    els.slide1.appendChild(els.controlsGroup);
                    els.slide2.appendChild(els.previewGroup);
                    els.mainContainer.appendChild(els.readerGroup);
                    els.mainContainer.appendChild(els.progressGroup);
                    els.mainContainer.appendChild(els.playbackGroup);
                }
                updateViewsForMode();
            }
        }
        window.addEventListener('resize', () => { clearTimeout(state.resizeTimer); state.resizeTimer = setTimeout(handleResize, 100); });
        
        // --- Init ---
        init();

        // Listeners for Play/Rewind/etc
        els.btnPlayPause.addEventListener('click', togglePlay);
        els.btnRestart.addEventListener('click', () => jumpToWord(0));
        els.btnRewind.addEventListener('click', () => jumpToWord(state.wordIndex - 10));
        els.wpmSlider.addEventListener('input', (e) => { state.wpm = parseInt(e.target.value); els.wpmDisplay.textContent = state.wpm; });
        els.progressSlider.addEventListener('input', (e) => jumpToWord(parseInt(e.target.value)));
        els.chapterSelect.addEventListener('change', (e) => jumpToWord(parseInt(e.target.value)));
        
        document.addEventListener('keydown', (e) => {
            // Check if user is typing in an input field or contenteditable div
            if (e.target.matches('input, textarea') || e.target.isContentEditable) return;

            if (state.words.length === 0) return;
            if (els.modal.classList.contains('active')) {
                if (e.code === 'ArrowLeft') showModalPage(state.currentPage - 1);
                if (e.code === 'ArrowRight') showModalPage(state.currentPage + 1);
                if (e.code === 'Escape') closeModal();
                return;
            }
            if (e.code === 'Space') { e.preventDefault(); togglePlay(); }
            else if (e.code === 'ArrowLeft') jumpToWord(state.wordIndex - 10);
            else if (e.code === 'ArrowRight') jumpToWord(state.wordIndex + 10);
        });

        // Carousel Touch
        let cStartX = 0, cEndX = 0;
        els.mobileCarousel.addEventListener('touchstart', e => cStartX = e.changedTouches[0].screenX, {passive: true});
        els.mobileCarousel.addEventListener('touchend', e => {
            cEndX = e.changedTouches[0].screenX;
            // Lock top widget if in text mode
            if (state.mode === 'text') return;

            if (!state.isDesktop && Math.abs(cEndX - cStartX) > 50) {
                state.carouselIndex = (cEndX - cStartX < 0) ? 1 : 0;
                updateCarousel();
            }
        }, {passive: true});

        function updateCarousel() {
            // Force Index 0 if in text mode on mobile to show controls
            if (state.mode === 'text' && !state.isDesktop) state.carouselIndex = 0;

            const offset = state.carouselIndex === 0 ? '0%' : '-50%';
            els.carouselTrack.style.transform = `translateX(${offset})`;
            
            if (state.carouselIndex === 0) {
                els.dot0.classList.add('active');
                els.dot1.classList.remove('active');
            } else {
                els.dot0.classList.remove('active');
                els.dot1.classList.add('active');
                const wordObj = state.words[state.wordIndex];
                if (wordObj && state.mode === 'pdf') renderPageThumbnail(wordObj.page);
            }
            updateViewsForMode();
        }

        // --- Bottom Widget (Reader Card) Logic ---
        // Swipe to Edit (Text Mode Only)
        let rStartX = 0;
        const readerCard = document.getElementById('reader-card'); // Use ID directly
        
        readerCard.addEventListener('touchstart', e => {
            rStartX = e.changedTouches[0].screenX;
        }, {passive: true});

        readerCard.addEventListener('touchend', e => {
            const rEndX = e.changedTouches[0].screenX;
            
            // Only active on Mobile and in Text Mode
            if (state.isDesktop || state.mode !== 'text') return;

            const diff = rEndX - rStartX;
            if (Math.abs(diff) > 50) {
                if (diff > 0) {
                    // Swipe Right: Show Editor
                    showMobileTextEditor();
                } else {
                    // Swipe Left: Start Reading
                    const text = els.mobileTextInput.value;
                    if (text.trim()) processRawText(text);
                }
            }
        }, {passive: true});

        function showMobileTextEditor() {
            stopReader();
            els.rsvpLayer.classList.add('hidden');
            els.mobileInputOverlay.classList.remove('hidden');
        }

    </script>
</body>
</html>